---
title: gson与fastjson选取与部分原理解答
date: 2018-10-11 20:50:28
tags: [工程,gson重构]
categories: android技能
---
* 项目中使用了多个解析库的时候，总会遇到一些取舍，那么我们可以从原理和解析速度上面来进行取舍，同时提高基础库的了解，便于今后对库进行改动和提升操作，下面就一起来讨论一下json的序列化和反序列化库的一些区别，探讨一些库的原理；
<!-- more -->
![image](gson-project-reconfigratijon/fastspeed.jpg)

## gson fastjson jackson ## 


gson fastjson jackson 三者都可以用来进行对象的序列化与反序列化操作，三者的速度对别，摘录下别人的结果，真实的结果估计也差不多，控制一下单一变量原则，对于各个序列方式擅长的方面，其实在开发中遇到的概率暂时不考虑；

序列化时间对比：

类库	| 样本数量	|执行次数		|最长时间(毫秒)	|最短时间(毫秒)		|平均时间(毫秒)
--|:--:|--:|--:|--:|--:|
FastJSON	|100000		|10				|2291.22	|1416.70		|1454.93
Jackson	 	|100000		|10				|1980.92	|841.91		|880.82
Gson	  	|100000		|10				|2383.02	|1469.08		|1520.38

反序列化对比：

类库	 	|	样本数量		|执行次数	|最长时间(毫秒)	|最短时间(毫秒)	|平均时间(毫秒)
--|:--:|--:|--:|--:|--:|
FastJSON	|100000		|10		|7942.31			|340.55			|6526.41
Jackson		|100000		|10		|7957.22			|6623.85			|6815.41
Gson		|100000		|10		|8235.15			|7006.06			|7364.75

从序列化和反序列化的表现来看，三种方案速度相差不是很大，所以在项目中已经使用了fastjson作为业务解析，gson用在了底层解析的时候，应该直接选取其中一种解析方式即可，不需要凭空在引进集中方案来增加包体积;


##  gson与fastjson  ##
```
	两种序列化方案是不应该放到一起的，毕竟对于速度相差不多，在不考虑易用性的时候，其实何种解析方案都可；鉴于gson被放到了网络底层来进行了数据的解析，那么我们最终选择了gson来进行序列化，而且渐渐是需要移除掉fastjson的依赖的；
	下面简单对比一下fastjson和gson在原理上的差异；
```

gson解析原理：
![image](gson-project-reconfigratijon/gson_show_main_flow.jpg)

fastjson解析：
https://blog.csdn.net/shangzonghai/article/details/79573698

```
	gson主要是通过遍历json和对象中的字段，遍历json进行类型判断，调取响应的TypeAdapter对象，再去bean中找到相对应的字段name生成一个boundfield，后续通过typeadapter进行数值的存入操作；直到解析结束，形成一个javabean，那么我们很容易就找到了gson会发生错误的最根本原因，在循环阶段就已经判断出来的字段类型，获取到bean中对应的typeadapter之后，尝试进行类型的转换时候，类型转换失败，自然会报出gson的一个自定义异常JsonSyntaxException，这个异常主要是针对于在类型强转过程中，统一catch之后，包装到自定义异常类中抛给调用方；
```
```
	fastjson解析原理：
	基于反射，在解析过程中，经过预测算法优化，加上各种缓存来提升速度；
	1.  专业的心做专业的事

	不论是序列化还是反序列化，FastJSON针对每种类型都有与之对应的序列化和反序列化方法，就针对这种类型来做，优化性能自然更具针对性。自编符合json的SerializeWriter和JSONLexer，就连ASM框架也给简化掉了，只保留所需部分。不得不叹其用心良苦。

	2.  无处不在的缓存

	空间换时间的想法为程序员屡试不爽，而作者将该方法用到任何细微之处：类对应的序列化器/反序列化器全部存起来，方便取用；解析的key存起来，表面重复内存分配等等。

	3.  不厌其烦的重复代码

	我不知道是否作者故意为之，程序中出现了很多类似的代码，比如特殊字符处理、不同函数对相同token的处理等。这样虽对于程序员寻求规整相违背，不过二进制代码却很喜欢，无形之中减少了许多函数调用。

	4.  不走寻常路

	对于JavaBean，可以通过发射实现序列化和反序列化（FastJSON已有实现），但默认使用的是ASM框架生成对应字节码。为了性能，无所不用其极。

	5.  一点点改变有很大的差别

	排序对输出仅是一点小小的改变，丝毫不影响json的使用，但却被作者用在了解析的快速匹配上，而不用挨个拎出key。

	6.  从规律中找性能

	上面也讲到，FastJSON读取token基于预测的。json串自身的规律性被作者逮个正着，预测下一个将出现的token处理比迷迷糊糊拿到一个token再分情况处理更快捷。
```
## json解析取舍 ##
```
	两种解析在根本上，速度不会相差太大，那么只需要保留一种解析即可，没有必要维护多个库，gson已经被使用到了网络库的底层中，那么最方便的方式就是去掉fastjson的解析库；只保留gson的解析方式；
```













