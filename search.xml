<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android event 事件分发的一些实用解析与源码分析汇总]]></title>
    <url>%2F2017%2F10%2F09%2Ftouchevent-all%2F</url>
    <content type="text"><![CDATA[前言工程中的一些需求需要定制很多的view，而定制的view如何进行这里不进行展开，但是其中遇到的一个问题足以引起重视，那就是view需要处理action事件(如 down , up , move ,cancle )，而总是出现处理了view的touch事件之后，在对view的onclicklistener监听的时候，监听不到点击事件，开始的处理是在网上查(zhan)找(tie)了下。现在好整以暇，可以看看究竟是什么样的机制让ontouch的事件监听了之后，没有onclicklistener的。或者是自己的使用姿势不对。 事件分发的一些概念事件：用户触摸屏幕产生的点击事件 系统将用户的操作事件包装成了一个motionevent的对象。(包含发生触摸的位置，时间，历史记录，手势动作等) 从源码的区分上来说： MOtionEvent.ACTION_DOWN: 用户按下事件 MotionEvent.ACTION_MOVE: 用户移动手指事件 MotionEvent.ACTION_CANCLE: 非用户操作取消事件 MotionEvent.ACTION_UP: 用户手指抬起事件 用户的一次操作的事件列用户的一次手指从按下到抬起的产生的一系列事件。 事件分发的几个分类window/activity , viewgroup 与 view讨论的事件分发除了是由docview分发的onclicklistener之外的诸如：dispatchevent,onintercepttouchevent,ontouchevent的一些事件，其中： widow/activity:dispatchevent,ontouchevent(没有onintercepttouchevent) viewgroup : dispatchevent,ontouchevent(没有onintercepttouchevent) view : dispatchevent,ontouchevent,onintercepttouchevent 基本的传递顺序是： activity—-&gt; viewgroup —-&gt; view e.g 在有多个viewgroup嵌套的时候，遵循一层一层往下传递的规律。 事件分发相关的方法事件分发在activity,viewgroup,view中传递的基本原则 事件分发QA1.view的事件分发的时候，ontouch拦截返回true/false时候，view的onclicklistener都不响应的问题。首先明白view的onclicklistener事件是docview或者说是acitivity的rootview分发给每个view的，那么首先我们要保证在顶层的activity要能获得事件。上图的分类是有问题的，当我们在view中拦截了ontouchevent的时候，传递的是false的时候，表示我们不处理给到父级来处理，但是在activity中没有接到相应的事件，没有给到onclicklistener点击事件。现象如下： 而当我们放开view的ontouchevent让而调用super的事件，那么会得到相应的结果。会响应view的onclick事件，所以，返回false和返回super是不一样的，对于onclick事件绑定来说，必须要把view的ontouchevent给到super，才能够让docview把事件给到view。 2.在上个实验中我们看到了acitivty中调用了两次的ontouchevent。用户的一次点击实际上是一个action_down和一次action_up组成的，所以，是传递了两个motionevent出来，那么activity–&gt;viewgroup—&gt;view是需要走两次的。 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>event事件解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[so库全解析]]></title>
    <url>%2F2017%2F09%2F18%2Fso-source-design%2F</url>
    <content type="text"><![CDATA[google android系统so库比较多的原因为适配众多的cpu架构，实际就是指令集的区别，在开始从复杂指令集改动到简易指令集的微软架构之后，又分出若干阵营，那么这个地方就不展开了，展开我怕篇幅不太够啊，少年。 android cpu架构分类android 当前支持的七种cpu架构Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。~ABI 应用程序二进制接口(Application binary interface)定义了二进制文件(so库)如何运行在相应的系统上。 每种cpu架构对应着一个ABIarmeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64 android如何去寻找so库原理android如何去寻找so库原理图解 android系统寻找so库的顺序，先区分架构，再去寻找完美适配的架构文件夹，若果找不到继续向兼容的架构寻找，匹配架构成功后，加载这个架构下所有的so到data文件夹中，如果在data中找不到应用中使用到的so库，那么会报异常，so link错误等等，不会再到其他架构中去扫描。 几个需要明白的概念主ABI库主ABI库： 与系统影响本身机器对应的ABI库辅助ABI库： 与系统也支持的ABI对应而，为实现最佳性能，应该提供主abi库 各个架构库支持的ABIX86 ： 可以运行在armeabi/armeabi-v7a 主要的ABI是X86,辅助ABI是armeabi-v7amips: 只定义了主ABI是mips(但是极少用于手机，可以忽略)armeabi-v7a ： 主 armeabi-v7a ， 辅助armeabi 只提供一种架构优缺点只提供一种架构优点：可以减小包的体积缺点： 只提供一种架构，而忽视其他架构，那么会影响到性能和兼容，同时也将丢失掉专门为64位优化的性能。 android找so库对于软件开发影响从根本上来说，系统只会把他区分架构的文件夹整个复制到data目录，那么造成一个问题就是，每个架构的文件夹下都应该是so库的全量，如果三方服务供应商，只给了一个armeabi-v7a 的架构，而工程中准备只放一个armeabi的文件夹来减小包大小，那么应该将v7a中的so库拷贝到armeabi中。 同时在运行在androidstudio工程中的build.gradle defaultConfig 中添加： ndk { abiFilters “armeabi” }在打包中，只包含armeabi的架构。 大厂对于so架构的一些取舍armeabi-v7a : facebook , twitterarmeabi: 淘宝 微信armeabi : 淘票票 还是来一个图来说明这个东西吧，毕竟没图你说个啥啊： 我可以大概算一个总结那么实际中我们的取舍遵从的原则：1.为减小体积，只保留armeabi与armeabi-v7a，一般只保留一个2.若只有一个架构，那么其他架构中的so，保留的文件夹下有有全量。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>so库实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[values在碎片化各种屏幕中的系统加载策略问题探讨及ui适配的选择]]></title>
    <url>%2F2017%2F09%2F15%2F2017-09-15-md%2F</url>
    <content type="text"><![CDATA[android寻找资源策略 values 两种系统识别文件夹，细分三种values-XXXXxXXXX values-swXXXdp (values-hXXXdp values-wXXXdp)三种系统识别的文件夹命令分别是指定分辨率，适配优先宽度，宽高适配 几种方式系统加载策略的探索项目中使用到了多个values来进行适配的问题，想从根本上弄清楚系统在加载的时候，对文件夹取用策略的判断问题，用实际例子对比了一下swXXXdp与values-1920X1080和默认的values的加载其中的策略指定问题，混合模式下，系统对values的取用问题。ok，开始吧。 添加values-1790X1080,values-1794X1076,values-1794X1080与values-sw361dp前三个文件夹用来对比在跟屏幕真实分辨率相差一些数值的时候，系统会加载那个文件夹下的配置。先用三个文件夹运行，观察结果： 当然是运行的完美契合的那个分辨率了，那么当我们在实际开发的时候，屏幕碎片化太大的时候，这种情况是可遇不可求的，故而需要去测试系统对与不完美契合的情况的处理，删除掉完美契合文件夹： 运行结果是： 加载到了1920X1148的values，那么说明在 1916X1152 与 1920X1148两个相近的宽高差值相同的文件夹中选择了高来进行优先选择，但是不能排除系统是把第一参数进行对比，而不是将values的匹配高进行优先匹配的，好吧，下面验证一下：改名为： 运行结果： 加载的还是高匹配高的那个文件夹，那么结论：系统对不能完美匹配的values文件，遵循的是，宽高差值绝对值进行对比，如果宽高对于当前屏幕分辨率差值小的进行加载，如果当宽高绝对值差值相同的时候，以高匹配度高的values进行加载。上面对比了在使用px来区分values的一些加载规则，那么当swXXXdp出现的时候，(sw—-small width)小宽度概念，当系统的宽度dp值大于该值的时候，加载这套设置。问题在于dp与px方式同时出现的时候，系统对于优先级的判定问题。下面进行判定：加入混合的值文件夹： 运行结果： 算是一个小总结google还是对dp情有独钟啊，1152/3= 384dp跟360还差那么多，要是在一个水平线上来进行对比的话，真真的应该加载1920X1152啊，完美适配的呢，说好的做彼此的天屎的，呸，天屎，算了。但是不管google怎么优先级，从细分上来说，如果是为了适配smartbar这个坑的话，一般来说，用px的values-1920X1152方式来进行细分适配要更加的精确，更能完美处理掉这个问题，毕竟还是在同一个水平上来处理的。但是官方是推sw-XXXdp的。综上所述：values-swXXXdp &gt; values-XXXXxXXXX &gt; values ;注： values-XXXXXxXXXXX 方式的时候，通过宽高跟屏幕分辨率的差值绝对值来进行对比，优先高。好吧，可能有人在等源码，我一起放上来吧 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>values实战</tag>
      </tags>
  </entry>
</search>
