<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[activity其中时，打印的totaltime是怎么来的包含哪些时间]]></title>
    <url>%2F2019%2F04%2F12%2Factivity-starttime-research%2F</url>
    <content type="text"><![CDATA[源码跟进 系统打印的totaltime是怎么来的通过activitymanager的displayed 时间来确定页面加载时间相关婆媳：Displayed com./com..activity.CoachDetailActivity: +293ms—从系统activitymanager接收到intent到显示目标页面的时间；( is basically the time spent between the Activity is about to be launched and the content view of the Activity is drawn (includes drawing time))针对的是页面绘制和布局层级的一些时间统计；只会得到一个从intent到inflate - drawing之后的时间消耗，并不能得到用户对于app的感知时间；参考： https://stackoverflow.com/questions/32844566/what-does-i-activitymanager-displayed-activity-850ms-comprised-of从28系统版本的源代码来看：com/android/server/am/ActivityStackSupervisor.java:1142打印的系统加载时间是来自于：void sendWaitingVisibleReportLocked(ActivityRecord r) { boolean changed = false; for (int i = mWaitingForActivityVisible.size() - 1; i &gt;= 0; –i) { final WaitInfo w = mWaitingForActivityVisible.get(i); if (w.matches(r.realActivity)) { final WaitResult result = w.getResult(); changed = true; result.timeout = false; result.who = w.getComponent(); result.totalTime = SystemClock.uptimeMillis() - w.getStartTime(); mWaitingForActivityVisible.remove(w); } } if (changed) { mService.notifyAll(); }}在其中记录页面开始加载时间的一个mWaitingForActivityVisible是一个list，维护在：com/android/server/am/ActivityStackSupervisor.java:352list中放的实体是：WaitInfocom/android/server/am/ActivityStackSupervisor.java:4906关键的一个starttime — mStartTimeMs来自于构造函数：WaitInfo(ComponentName targetComponent, WaitResult result, long startTimeMs) { this.mTargetComponent = targetComponent; this.mResult = result; this.mStartTimeMs = startTimeMs;}最终跟踪过去发现系统源码只有一个地方在用这个构造函数，在void waitActivityVisible(ComponentName name, WaitResult result, long startTimeMs) { final WaitInfo waitInfo = new WaitInfo(name, result, startTimeMs); mWaitingForActivityVisible.add(waitInfo);}看到这里就已经比较熟悉了，一个actvityvisible；调用这个visible的地方：com/android/server/am/ActivityStarter.java:1205case START_TASK_TO_FRONT:在其中的startActivityMayWait方法中，而调用该方法的入口只来自了（在这里可以跟着看下，源代码中有个判断，if (mRequest.mayWait) { return startActivityMayWait(…);} else { return startActivity(…..);} 这个判断中mayWait 初始化的值是false，最后看了下系统中的startActivityAsUser 其中setMayWait(userId) 竟然把maywait又给设置为true了，这操作。。所以当前看基本都到了startActivityMayWai中了）com/android/server/am/ActivityStarter.java:487 int execute()跟踪到比较熟悉的startActivityAsUser ，再往上一层，最终看到的代码是：@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());} @Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /validateIncomingUser/);} 恭喜，最终我们得到这个totaltime的时间是来自于：从startinent的START_TASK_TO_FRONT 任务开始记录开始时间，com/android/server/am/ActivityRecord.java:2023 onWindowsVisible 结束计时并且打印出来,也就是这段时间包括了从startactivity到用户能看见布局的时间；]]></content>
      <categories>
        <category>android技能,源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型的使用注意事项与字节码解读]]></title>
    <url>%2F2019%2F04%2F11%2Fgeneric-learn%2F</url>
    <content type="text"><![CDATA[泛型的使用与对应的字节码 泛型的弊端 泛型的使用与对应的字节码Generics 允许开发抽象算法和数据结构，并提供实体类型以供后续操作 ， 即“参数化类型”，编译阶段就直接检查泛型类型的兼容性,泛型信息不会进入到运行期；类型擦除； （接口、类、和方法） 定义一个泛型的接口： public interface GInterface &lt;T,R&gt;{ T perform(R r); //提供了个开放的接口定义，允许从使用端，调用端来指定方法的入参和返回参数； } 在字节码中表现： annotation system Ldalvik/annotation/Signature; value = { &quot;&lt;T:&quot;, &quot;Ljava/lang/Object;&quot;, &quot;R:&quot;, &quot;Ljava/lang/Object;&quot;, &quot;&gt;&quot;, &quot;Ljava/lang/Object;&quot; } .end annotation T，R最终都会再编译器被类型擦除为同一个object类； 所以说：编译阶段的一个使用方式，不会进入运行期，在此期间会被类型擦除掉； 定义一个类的泛型： public class GInterfaceImp3&lt;T,R&gt; implements GInterface &lt;T,R&gt;{ // 泛型实现接口的时候，只指定其中的泛型类； // @Override // public &lt;T,R&gt;T perform(R r) { // R r1 = r; // String name = r1.getClass().getName(); // // return null; // } @Override public T perform(R r) { List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); return null; } } 字节码中的表现： # virtual methods .method public perform(Ljava/lang/Object;)Ljava/lang/Object; .registers 5 .annotation system Ldalvik/annotation/Signature; value = { &quot;(TR;)TT;&quot; } .end annotation 从接口中实现过来的方法，也被类型擦除掉了； 从这个方向来说，泛型其实可以使用object父类来进行替换的，然后每次都是向上转型么？ 定义一个方法的泛型： // 方法中定义自己的泛型； public&lt;U,R&gt; R action(U u){ R result = null; return result; } 字节码中的表现： # virtual methods .method public action(Ljava/lang/Object;)Ljava/lang/Object; .registers 3 .annotation system Ldalvik/annotation/Signature; value = { &quot;&lt;U:&quot;, &quot;Ljava/lang/Object;&quot;, &quot;R:&quot;, &quot;Ljava/lang/Object;&quot;, &quot;&gt;(TU;)TR;&quot; } .end annotation 123456789101112131415161718192021222324252627 /** * ? 通配符的使用 只能用来填充通配符泛型变量，表示通配任何类型； * 注意：利用&lt;? extends Number&gt;定义的变量，只可取其中的值，不可修改 */ GInterface&lt;?,?&gt; gInterfaceimp1 = new GInterfaceImp3&lt;String , String&gt;();// gInterfaceimp1.perform(&quot;&quot;);// gInterfaceimp1.perform(); Log.e(&quot;&quot; + TAG , &quot;&quot;);// /** * 如果你想从一个数据类型里获取数据，使用 ? extends 通配符（能取不能存） * 通配符的使用 * 注意：利用&lt;? extends Number&gt;定义的变量，只可取其中的值，不可修改 */ List&lt;? extends Integer&gt; extendsGeneric; extendsGeneric = new LinkedList&lt;Integer&gt;();// extendsGeneric.add(1); //报错 /** * 如果你想把对象写入一个数据结构里，使用 ? super 通配符（能存不能取） */ List&lt;? super String&gt; superGeneric = new LinkedList&lt;String&gt;(); superGeneric.add(&quot;&quot;); String s = (String) superGeneric.get(0); /** * 如果你既想存，又想取，那就别用通配符。 */ 泛型的弊端：1.类型擦除 -- 造成在重载方法的时候，因为此爆出：Erasure of method sort(Collection&lt;String&gt;) is the same as another method 方法重载失败； 同时，不能以任何有意义的方式来使用该类型； 2.不能使用基本数据类型，只能使用对应的包装类； 3.通配符使用限制；]]></content>
      <categories>
        <category>通用技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lottie解析，原理剖析，优缺点]]></title>
    <url>%2F2019%2F02%2F27%2Flottie-analysis%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 适合在哪种场景使用 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点 上代码例子 这个技术解决了什么问题 控件或者是元素在移动端的实现一直都是比较麻烦，而且收效不高的地方。（如果是手势或者是联动之内的动画不在讨论范围内），设计给出的一些效果，每次的沟通也会产生信息的衰减，那么爱彼迎在这基础上，给出了一套可以让设计师直接能给出一手的效果文件，经过客户端的转换成一个他想要的动画； lottie能够解决以下的一些问题： 1.android ， ios ， rn 对于某一个动画效果实现两次； 2.设计师表述的效果，跟实际沟通之间的问题，或者给出的动画实例实现有误差； 3.复杂的动画，实现耗时长； 适用： 适合在哪种场景使用适用场景： 1.稍复杂的动画，糅合了各种animation和animator的动画 2.其他懒得实现的场景。。。。 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点lottie从根本上还是一个对于图片元素的动画执行路径和执行时间的一个json文件描述转换成animation动画。那么从实现的机制上来说本身就有自己的局限性的，很多涉及到手势操作和animator的操作都无法好的进行适配；本质上是一系列的animationset的集合，需要透明度的实现还需要图片来进行支持，需要开发者自己指定mask图片的本地assert路径； 缺点： 1.lottie类似animation，所以lottie动画本身的scale都是动画变动，真是占用的区域还是文件描述的宽高(需要有缩放之内动画的要么端自己实现，要么就直接按照缩放之前之后的宽高，另行设置点击事件；) 2.对于涉及到mask ， mattes的动画，实现需要有些注意点； 3.对于recyclerview支持不是很好，对于新能会有影响；（尤其是涉及到mask，mattes相应的动画） 优点： 1.轻量，整个包只有700多个方法 2.两端实现成本会低一些； 3.动画效果实现度高，设计师设计即所得； 原理解析：Lottie使用json文件来作为动画数据源，json文件是通过Bodymovin插件导出的，查看sample中给出的json文件，其实就是把图片中的元素进行来拆分，并且描述每个元素的动画执行路径和执行时间。Lottie的功能就是读取这些数据，然后绘制到屏幕上。 首先要解析json，建立数据到对象的映射，然后根据数据对象创建合适的Drawable绘制到view上，动画的实现可以通过操作读取到的元素完成。 具体过程如下所示 json文件——&gt;Component——&gt;Drawable——&gt;View 通过如下3个核心类来来完成整个工作流程，因而使用起来比较简单 LottieComposition(json-&gt;数据对象)Lottie使用LottieComposition来作为After Effects的数据对象，即把Json文件映射为到LottieComposition，该类中提供了解析json的静态方法 LottieDrawable(数据对象-&gt;Drawable)绘制 LottieAnimationView（绘制）操作集合，LottieAnimationView 继承自 AppCompatImageView，封装了一些动画的操作，具体的绘制时委托为 LottieDrawable 完成的 上酸菜，咳咳，上代码例子]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓存储方式完全讲解]]></title>
    <url>%2F2019%2F01%2F23%2Fandroid-datasave-type%2F</url>
    <content type="text"><![CDATA[文件存储方式 android 中的存储 名称 速度 安全性 多线程支持 文件 慢 (私有文件外)否 读写现成不安全 数据库 快 安全 由sqlite database保证线程安全 ContentProvider 视底层数据存储而定 安全 过程线程安全 shareprefrence 慢(转存到xml中为止) private安全 不安全 mmkv 快 可控 安全 123各种存储方式根据特性，1.可以在需要的时候进行选择；2.没有一种存储方式适用于所有的情况；3.只能根据业务和功能的需求，选择合适的存储方式； 文件存储方式12文件的存储，指在安卓系统中，以文件方式放在内部存储或者外部存储的方式；文件存储可以存放比较大的数据，图片，视频，同时对于大量的android运行日志，dump日志，apk，临时碎片推荐使用文件的方式，根据所存储文件的安全性要求和文件存储位置要求来选择合适的存储位置文件存储位置分为两种：内部存储，外部存储两种； （内部存储）路径 存储内容 api data/data/包名/shared_prefs 存储sp文件 .. data/data/包名/databases 数据库文件 .. data/data/包名/files 文件存储 context.getFilesDir() data/data/包名/cache 缓存 context.getCacheDir() （外部存储 mnt/storage ）路径 存储内容 api 九大公用存储+sd卡目录 存储sp文件 .. 私有目录 storage/sdcard/android/data/包名/file 文件 context.getExternalFilesDir(Environment.DIRECTORY_MUSIC) 私有目录 storage/sdcard/android/data/包名/file 缓存 context.getExternalFilesDir() 方法 路径 /storage/sdcard0/Alarms Environment.getExternalStoragePublicDirectory(DIRECTORY_ALARMS) /storage/sdcard0/DCIM Environment.getExternalStoragePublicDirectory(DIRECTORY_DCIM) /storage/sdcard0/Download Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS) /storage/sdcard0/Movies Environment.getExternalStoragePublicDirectory(DIRECTORY_MOVIES) /storage/sdcard0/Music Environment.getExternalStoragePublicDirectory(DIRECTORY_MUSIC) /storage/sdcard0/Notifications Environment.getExternalStoragePublicDirectory(DIRECTORY_NOTIFICATIONS) /storage/sdcard0/Pictures Environment.getExternalStoragePublicDirectory(DIRECTORY_PICTURES) /storage/sdcard0/Podcasts Environment.getExternalStoragePublicDirectory(DIRECTORY_PODCASTS) /storage/sdcard0/Ringtones Environment.getExternalStoragePublicDirectory(DIRECTORY_RINGTONES) 1在路径中带了包名的代码访问需要使用context需要使用上下文，没有带包名的，可以直接使用enviroment的方法进行访问； 数据库123```![image](android-newplatform-adaptation-md/google_apisdk_permission.jpg)## 工程中已经发现需要注意的三方库 ## 详细分析： http://kuaibao.qq.com/s/20180327G17Y3L00?refer=spider 扫描工具： 链接: https://pan.baidu.com/s/1J6ZvwWt16imoWoODY7dWXA 提取码: 29yy]]></content>
      <categories>
        <category>android技能,存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vysor共享手机屏幕高清破解]]></title>
    <url>%2F2019%2F01%2F21%2Fandroid-vysor-chrome-plugin%2F</url>
    <content type="text"><![CDATA[chrome 插件vysor高清模式破解 vysor共享手机屏幕破解123456789101112131415chrome插件都是本地的js脚本，验证和校验是否是有效用户有V权限用户，都在本地是可以进行本地破解的；首先下载vysor插件 [官网](http://www.vysor.io/)安装完成后,打开用chrome打开 chrome://version/ 查看 个人资料路径例子: /Users/XXX/Library/Application Support/Google/Chrome/Default之后进入Extensions文件夹 找到gid带头的文件夹 里面就是插件的目录之后打开uglify.js 为了更直观的修改最好格式化下需要更改两个地方:第一个:首先查找_il 直接将后面改成true ;作者可能会重新打包所以后面的内容可能会有变动;目前我的是 _il:We.a();第二个:查找&quot;Account Management&quot;将上面的三个变量的值 都改成1;目前我的是: var e, t = !1,o = !1,都改成 var e = 1, t = 1,o = 1,之后从打开vysor:chrome://apps/看到变成了vysor pro就表示成功了。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《行动变现》 读书笔记]]></title>
    <url>%2F2018%2F12%2F09%2Freading-book-tag-1-20181209%2F</url>
    <content type="text"><![CDATA[《行动变现》 第二章 决定你未来的三架马车 《行动变现》 第三章 《让目标来有效的管理时间》 《行动变现》 第二章 决定你未来的三架马车123456789《掌握专业能力，生活将不一样》1.预期管理：不再开始的时候提高期望层级，而是适当留出一部分合适的缓冲时间；2.写作技能是通用技能，不管是什么职级什么岗位，能说与能写一定要相互结合来做；3.工作中： 需要有统览全局的思维，而不是接手开始就埋头工作，知道你的业务方核心关注点在哪哪些又是下游发散出来影响你工期工作的点，尽量规避；4.在工作中，可以以图表，文字记录的东西尽量整理出架构，可以方便别人使用，同事也能更好的了解全局情况，也是在工作中差异化的东西，可以突出不同；《一定告诉别人你很值钱》1.明码标价自己的剩余时间，也对其他专业人才给出回报，可以得到更加专业的结果。不能把自己的时间贱卖了，收费会过滤80%的请求但是会剩20%的付费用户，而这20%用户还会带来更多的机会； 不用出卖的时间可以拿来做自己 想做的事情，而不用困于琐事当中； 第三章 《让目标来有效的管理时间》12345678910《如何有效的管理你的时间》1.不推荐写满自己的时间表，不用强制某个点完成什么，但是可限定每天完成什么，并且空闲下来换脑子之后就需要进入下一项日程中。2.不要高估自己的效率，任何事情都需要前置项，充分考虑，再给出估算时间更加靠谱；3.剩余时间的剩余价值问题，万事开头一般会有一个结果，一般的没有时间说明事情被排到了不紧急同时不重要的象限中；4.整块时间来做整块事情或是相近的事情，避免在事情中频繁切换带来的消耗，这与之前说的番茄工作法相违背，而微信与钉钉的碎片化切割也会降低效率，番茄仔认知里面可以相似的认为是符合大众的小白班和小白课堂，是针对对于初级学渣而设置的规则适用于所有人，那么必然是一个易接受的程度；《相信复利的力量》复利： 指一笔资产在下一个计息周期内，上一期的利息也计算利息，也就是“上期本息，作为下期本金”1.坚持去做一件事，持续做，最后会获得超越预期的成果；2.以坚持的时候不要跟365天都一样的人讨论看法，而应该看齐在自我要求高在行业不错的人。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>行动变现</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android9.0适配的前世今生]]></title>
    <url>%2F2018%2F10%2F29%2Fandroid-newplatform-adaptation-md%2F</url>
    <content type="text"><![CDATA[andorid 9.0 渐进的改进方式 sdk检查原理 工程中已经发现需要注意的三方库 andorid 9.012google终于开始解决悬在自己头上的达摩斯之剑了，安全+卡顿两个被诟病的地方；这次在nogout的p升级上，开始对sdk中被各大厂商和黑科技玩坏的反射和对底层的各种调用问题开始着手解决；这个版本对于非sdk暴露api方法做了限制，不论是调用，反射还是jni，提升自己的兼容性；对限制的接口进行调用的时候，会奔溃或者弹窗或者弹出toast警告的方式来一个版本一个版本的把非法的sdk调用消灭掉； 渐进的改进方式1对于sdk的限制，google出了几个列表，blacklist，dark-graylist， light-graylist；处理方式也有不同，对于黑名单这个版本必须改动，不然会带来奔溃；dark-graylist的接口，为p版本的时候不准调用，小于p的手机可调用，会警告；light-graylist的在》=p的版本的时候会进行警告，后续版本会移动到深灰列表中； sdk检查原理123456789101112131415161718192021222324252627282930313233343536373839start 准备阶段： 在c层对androidsdk的api权限进行检测从编译期的几个api列表中开始： LOCAL_LIGHT_GREYLIST := $(INTERNAL_PLATFORM_HIDDENAPI_LIGHT_GREYLIST) LOCAL_DARK_GREYLIST := $(INTERNAL_PLATFORM_HIDDENAPI_DARK_GREYLIST) LOCAL_BLACKLIST := $(INTERNAL_PLATFORM_HIDDENAPI_BLACKLIST) # File names of source files we will use to generate the final API lists. LOCAL_SRC_GREYLIST := frameworks/base/config/hiddenapi-light-greylist.txt LOCAL_SRC_VENDOR_LIST := frameworks/base/config/hiddenapi-vendor-list.txt LOCAL_SRC_FORCE_BLACKLIST := frameworks/base/config/hiddenapi-force-blacklist.txt LOCAL_SRC_PUBLIC_API := frameworks/base/config/hiddenapi-public-dex.txt LOCAL_SRC_PRIVATE_API := frameworks/base/config/hiddenapi-private-dex.txt LOCAL_SRC_REMOVED_API := frameworks/base/config/hiddenapi-removed-dex.txt 在定义light-greylist，black-list，dark-greylist中可以看出，系统开始就存储了两个列表hiddenapi-blacklist.txt，hiddenapi-dark-greylist.txt来源于Framework/base/config目录，而light-greylist来自于private-list减去dark-list和black-list表的并集之后的结果集；1.遍历class.dex中的函数或者字段列表 按照： HiddenApiAccessFlags::kWhitelist =&gt; 0b00 hiddenapi-light-greylist.txt=&gt; HiddenApiAccessFlags::kLightGreylist =&gt; 0b01 hiddenapi-dark-greylist.txt =&gt; HiddenApiAccessFlags::kDarkGreylist=&gt; 0b10 hiddenapi-blacklist.txt =&gt; HiddenApiAccessFlags::kBlacklist =&gt; 0b11 的对应表将数值写入到ClassDataMethod/ClassDataField结构体中成员access_flags_原始值进行处理后重新写入2.最后一步，重新校验dex头部签名 Hiddenapi处理后，完成从3个文本文件数据与原始dex格式文件的合并，即生成新的dex。3.Art Runtime时期 将 access_flags_转换为需要的值； hiddenapi-light-greylist.txt (0b01) hiddenapi-dark-greylist.txt (0b10) hiddenapi-blacklist.txt (0b11) 将转换之后的2进制值再存入进去，等待在运行期再使用；4.运行期：在app运行时，会校验artmethod结构体中access_flags_最高2位的值，校验的手段包括直接调用、反射、JNI获取 0(0b00) kAllow直接放过 1(0b01) kAllowButWarn放过，但日志警告 2(0b10) kAllowButWarnAndToast放过，且日志警告和弹窗 3(0b11) kDeny拒绝那么在用户和开发层面表现出来的现象就是： 工程中已经发现需要注意的三方库1作为一个已经运行了三年的工程在项目里面不可避免的引入了一些对于google不太友好的sdk进来，现在发现的是tinker和gson的低版本会造成引入比较多的非法sdkapi不过可以通过升级到最新的三方版本来进行规避； 其他很奇怪的开发版造成的适配问题123456789101112131415161718192021222324252627// Android 9.0 限制了开发者调用非官方公开API方法或接口, 关闭警告弹框private void closeAndroidPDialog()&#123; try &#123; Class clazz = Class.forName(&quot;android.content.pm.PackageParser$Package&quot;); Constructor constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; Class clazz = Class.forName(&quot;android.app.ActivityThread&quot;); Method method = clazz.getDeclaredMethod(&quot;currentActivityThread&quot;); method.setAccessible(true); Object object = method.invoke(null); Field filed = clazz.getDeclaredField(&quot;mHiddenApiWarningShown&quot;); filed.setAccessible(true); filed.setBoolean(object, true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;这种方式不推荐使用，只是在最终的适配也无法满足的 mix 2s 开发版 9.0 时候特定的适配问题添加下； 引出一个android p的 适配1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992001.hidden api 限制描述:Android P（API 级别 28）引入了针对非 SDK 接口的使用限制，无论是直接使用还是通过反射或 JNI 间接使用，均会收到此限制。google使用三个名单对私有api划分为3个级别: 1.light grey 2.dark grey 3. black.(1) light grey名单的api仍然可以使用, 但是会在debuggable的应用上弹窗警；(2) dark grey名单的api限制了targetSdk等级28的应用抛出异常, 对于低于28的应用处理原则与light grey名单的api一致；(3) black名单会限制所有应用使用, 使用会导致崩溃。适配建议:1.遵循google的规定使用sdk允许范围内的api。可以使用google发布的veridex工具进行静态检查, 链接（VPN环境下打开）:https://android.googlesource.com/platform/prebuilts/runtime/+/master/appcompat2.如果有一定理由一定要使用某个被限制的api, 可以反馈google申请将api限制降级。2.加固类异常描述: 经测试本次升级某些加固方案在 Android P 上依然存在兼容性问题，会造成应用启动crash。 适配建议: 使用加固的应用厂商应该及时更新到最新的加固版本以确保对 Android P 的支持, 如果更新后仍有问题请反馈我们, 我们再尝试跟加固厂商沟通解决。3.targetSdk限制描述: 在 Android P 的设备上运行的应用必须保证targetSdk版本&gt;=17, 否则强制弹框提示。由于google明确要求, 此提示不可消除。 适配建议: 请尽快提升targetSdk级别到17以上。 4.限制访问WiFi位置和连接信息描述: 在 Android P 上如果应用需要wifi获取位置信息以及获取wifi的SSID和BSSID, 除开必要的权限 ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION CHANGE_WIFI_STATE 还需要用户打开位置开关 适配建议: 获取上述信息时可以考虑通过以下接口判断位置开关是否打开, 从而引导用户操作。 Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE,Settings.Secure.LOCATION_MODE_OFF)5.Apache HTTP客户端弃用描述: Google从android 6.0开始取消对于Apache Http客户端的支持, 在 Android P 将其从bootclasspath中移除,通过委托系统classLoader将不再能查找到org.apache.http.*(应用classLoader仍能查找) 这个变更造成了两个影响: 1.使用非标准classLoader会造成NoClassDefFoundError错误； 2.仅针对targetSdk等级28以上的应用,继续使用Apache HTTP客户端，以 Android P及更高版本为目标的应用可以向其 AndroidManifest.xml 添加以下内容： &lt;uses-library android:name=&quot;org.apache.http.legacy&quot;android:required=&quot;false&quot;/&gt;。 适配建议: 1.遵循google建议使用HttpURLConnection类替代Apache HTTP客户端使用； 2.如仍要使用使用，需要在build.gradle中申明 android &#123; useLibrary &apos;org.apache.http.legacy&apos; &#125;对于targetSdk等于28的应用, 还需要再并在AndroidManifest.xml中申明 &lt;uses-library android:name=&quot;org.apache.http.legacy&quot;android:required=&quot;false&quot;/&gt;。或者自己打包Apache HTTP客户端使用。 6.禁止处于idle状态应用访问相机、麦克风和传感器描述: Google从安全隐私的角度, 限制了后台应用的使用相机、麦克风和传感器(会改善)。 应用退到后台进入idle状态后, 应用将无法调用相机、麦克风和传感器, 可能会导致某些应用后台的功能异常。 适配建议: 1.尽量避免后台访问这些功能； 2.必须后台使用的可以通过启动前台服务的方式实现。 7.安全行为变更描述: 1.Crypto Java 加密架构 (JCA) 提供程序现已被移除, 调用 SecureRandom.getInstance(&quot;SHA1PRNG&quot;, &quot;Crypto&quot;) 将会引发 NoSuchProviderException； 2. Android P 弃用了几个来自 Bouncy Castle 提供程序中的加密技术，代之以由 Conscrypt 提供程序提供的加密技术； 调用请求 Bouncy Castle 提供程序的 getInstance() 时，会生成 NoSuchAlgorithmException 错误； 3.更严格的 SECCOMP 过滤器。 8.强制执行FLAG_ACTIVITY_NEW_TASK要求 描述: 现在从非Activity启动, 必须要添加FLAG_ACTIVITY_NEW_TASK的flag, 否则这个intent将不被响应。 9.应用不再能访问xt_qtaguid文件夹中的文件描述: 从 Android P 开始，不再允许应用直接读取 /proc/net/xt_qtaguid 文件夹中的文件。 这样做是为了确保与某些根本不提供这些文件的设备保持一致。 依赖这些文件的公开 API TrafficStats 和 NetworkStatsManager 继续按照预期方式运行。 然而, 不受支持的 cutils 函数, 例如 qtaguid_tagSocket()执行结果可能异常。 影响范围API级别28的应用(申明适配 Android P 的应用) 10.前台服务描述: 现在应用必须为启动前台服务申请权限FOREGROUND_SERVICE， 这是一个普通权限，不需要。 11.隐私权变更描述: 1.构建序列号弃用 在 Android P 中，Build.SERIAL 始终设置为 &quot;UNKNOWN&quot; 以保护用户的隐私； 如果您的应用需要访问设备的硬件序列号，您应改为请求 READ_PHONE_STATE 权限，然后调用 getSerial()； 2.DNS 隐私 以 Android P 为目标平台的应用应采用私有 DNS API。 具体而言，当系统解析程序正在执行 DNS-over-TLS 时，应用应确保任何内置 DNS 客户端均使用加密的 DNS 查找与系统相同的主机名，或停用它而改用系统解析程序。 12.框架安全性变更描述: 1.默认情况下启用网络传输层安全协议 (TLS)； 如果您的应用以 Android P 或更高版本为目标平台，则默认情况下 isCleartextTrafficPermitted() 函数返回 false； 如果您的应用需要为特定域名启用明文，您必须在应用的网络安全性配置中针对这些域名将 cleartextTrafficPermitted 显式设置为 true。 2.为改善 Android P 中的应用稳定性和数据完整性，应用无法再让多个进程共用同一 WebView 数据目录。 此类数据目录一般存储 Cookie、HTTP 缓存以及其他与网络浏览有关的持久性和临时性存储。 在大多数情况下，您的应用只应在一个进程中使用 android.webkit 软件包中的类，例如 WebView 和 CookieManager。 例如，您应该将所有使用 WebView 的 Activity 对象移入同一进程。 您可以通过在应用的其他进程中调用 disableWebView()，更严格地执行“仅限一个进程”规则。 该调用可防止 WebView 在这些其他进程中被错误地初始化，即使是从依赖内容库进行的调用也能防止。 如果您的应用必须在多个进程中使用 WebView 的实例，则必须先利用 WebView.setDataDirectorySuffix() 函数为每个进程指定唯一的数据目录后缀，然后再在该进程中使用 WebView 的给定实例。 该函数会将每个进程的网络数据放入其在应用数据目录内自己的目录中。13.CSS颜色模块级别4描述: Chrome 自版本52以来便一直支持 CSS 颜色模块级别 4，但webview目前停用此功能，因为现有Android应用被发现包含Android ordering (ARGB)中的32位十六进制颜色，这会导致渲染错误。 例如，对于以API级别27或更低版本为目标平台的应用，颜色#80ff8080目前在WebView中被渲染为不透明浅红色(#ff8080)。 先导部分(Android会将其解读为Alpha部分)目前被忽略。 如果某个应用以 API 级别 28 或更高版本为目标，则#80ff8080将被解读为 50% 透明浅绿 (#80ff80)。 Tips：随着Google新版本发布，各应用应尽快跟进兼容。否则后面有多个版本的迭代，遗留的坑会比较多哦~ 详细分析： http://kuaibao.qq.com/s/20180327G17Y3L00?refer=spider 扫描工具： 链接: https://pan.baidu.com/s/1J6ZvwWt16imoWoODY7dWXA 提取码: 29yy]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gson与fastjson选取与部分原理解答]]></title>
    <url>%2F2018%2F10%2F11%2Fgson-project-reconfigratijon%2F</url>
    <content type="text"><![CDATA[项目中使用了多个解析库的时候，总会遇到一些取舍，那么我们可以从原理和解析速度上面来进行取舍，同时提高基础库的了解，便于今后对库进行改动和提升操作，下面就一起来讨论一下json的序列化和反序列化库的一些区别，探讨一些库的原理； gson fastjson jackson天下武功，无坚不摧，唯快不破gson fastjson jackson 三者都可以用来进行对象的序列化与反序列化操作，三者的速度对别，摘录下别人的结果，真实的结果估计也差不多，控制一下单一变量原则，对于各个序列方式擅长的方面，其实在开发中遇到的概率暂时不考虑； 序列化时间对比： 类库 样本数量 执行次数 最长时间(毫秒) 最短时间(毫秒) 平均时间(毫秒) FastJSON 100000 10 2291.22 1416.70 1454.93 Jackson 100000 10 1980.92 841.91 880.82 Gson 100000 10 2383.02 1469.08 1520.38 反序列化对比： 类库 样本数量 执行次数 最长时间(毫秒) 最短时间(毫秒) 平均时间(毫秒) FastJSON 100000 10 7942.31 340.55 6526.41 Jackson 100000 10 7957.22 6623.85 6815.41 Gson 100000 10 8235.15 7006.06 7364.75 从序列化和反序列化的表现来看，三种方案速度相差不是很大，所以在项目中已经使用了fastjson作为业务解析，gson用在了底层解析的时候，应该直接选取其中一种解析方式即可，不需要凭空在引进集中方案来增加包体积; gson与fastjson12两种序列化方案是不应该放到一起的，毕竟对于速度相差不多，在不考虑易用性的时候，其实何种解析方案都可；鉴于gson被放到了网络底层来进行了数据的解析，那么我们最终选择了gson来进行序列化，而且渐渐是需要移除掉fastjson的依赖的；下面简单对比一下fastjson和gson在原理上的差异； gson解析原理： fastjson解析：https://blog.csdn.net/shangzonghai/article/details/79573698 1gson主要是通过遍历json和对象中的字段，遍历json进行类型判断，调取响应的TypeAdapter对象，再去bean中找到相对应的字段name生成一个boundfield，后续通过typeadapter进行数值的存入操作；直到解析结束，形成一个javabean，那么我们很容易就找到了gson会发生错误的最根本原因，在循环阶段就已经判断出来的字段类型，获取到bean中对应的typeadapter之后，尝试进行类型的转换时候，类型转换失败，自然会报出gson的一个自定义异常JsonSyntaxException，这个异常主要是针对于在类型强转过程中，统一catch之后，包装到自定义异常类中抛给调用方； 12345678910111213141516171819202122232425fastjson解析原理：基于反射，在解析过程中，经过预测算法优化，加上各种缓存来提升速度；1. 专业的心做专业的事不论是序列化还是反序列化，FastJSON针对每种类型都有与之对应的序列化和反序列化方法，就针对这种类型来做，优化性能自然更具针对性。自编符合json的SerializeWriter和JSONLexer，就连ASM框架也给简化掉了，只保留所需部分。不得不叹其用心良苦。2. 无处不在的缓存空间换时间的想法为程序员屡试不爽，而作者将该方法用到任何细微之处：类对应的序列化器/反序列化器全部存起来，方便取用；解析的key存起来，表面重复内存分配等等。3. 不厌其烦的重复代码我不知道是否作者故意为之，程序中出现了很多类似的代码，比如特殊字符处理、不同函数对相同token的处理等。这样虽对于程序员寻求规整相违背，不过二进制代码却很喜欢，无形之中减少了许多函数调用。4. 不走寻常路对于JavaBean，可以通过发射实现序列化和反序列化（FastJSON已有实现），但默认使用的是ASM框架生成对应字节码。为了性能，无所不用其极。5. 一点点改变有很大的差别排序对输出仅是一点小小的改变，丝毫不影响json的使用，但却被作者用在了解析的快速匹配上，而不用挨个拎出key。6. 从规律中找性能上面也讲到，FastJSON读取token基于预测的。json串自身的规律性被作者逮个正着，预测下一个将出现的token处理比迷迷糊糊拿到一个token再分情况处理更快捷。 json解析取舍1两种解析在根本上，速度不会相差太大，那么只需要保留一种解析即可，没有必要维护多个库，gson已经被使用到了网络库的底层中，那么最方便的方式就是去掉fastjson的解析库；只保留gson的解析方式；]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>gson重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身行业认识]]></title>
    <url>%2F2018%2F09%2F29%2Ftrade-healthy-knowledge%2F</url>
    <content type="text"><![CDATA[健身行业 公司正在做的事情 可能存在的问题 可能的解决办法 健身行业123456健身行业的现在玩家分为： 1.团操-超级星星 2.私教 3.户外跑-光猪跑，彩色跑各种跑 4.传统健身房-买年卡吸用户 5.线上运动方向-keep 12对于行业内的一些问题，也都有各自的解决方案，从健身门槛过高，开始的传统健身房通过年卡这种比较重的方式，通过低频用户来养高频和场地费用换取利润的方式，对于90后来说过于重了些，传统健身房在新兴的健身房铺量的打击下会渐渐失去新生代用户，而失去年轻一代就代表失去未来。年轻一代的不固定性，常变的生活状态，处于工作生活甚至还要加上学校的几地生活状态，在一个单个健身房办卡无法通用，时间无法满足的情况会变得越来越难忍受。年轻人需要的是，短期-密度-方便-便宜。keep在一定的程度上满足了轻量，短期，场地实用性大，灵活，年轻态的需求，不过处于健身需求升级的人必然会寻求另外的专业的场地和器材，大肌霸这样的程度健身是无法在小场地小器材上满足的。 公司正在做的事情1234567891011线上： 1.提供一个可以自由约课，自由上课，自由锻炼的平台，7X24小时的服务，全国十城通用的月卡，更加轻量。 2.提供适用于全国的活动，单个城市区分度的活动，刺激运动的欲望。 3.提供专业的设备，测试身体的当前状态，比传统的教练用目测更加科学可信。应该明白用肉眼无法触达到骨骼肌含量，无法知道体脂含量； 4.提供教练的成长平台，关注教练的成长与教育，关注用户的体验反馈；线下： 1.建设大量的场馆，提供多的健身设备，适用于更多的健身需求； 2.配备私教区域 ， 认证私教可随时到场教授课程； 3.配备团操区域，让用户能上更多的免费，收费的私教，更多选择；总说：首家99元包月，月单场地百余节课程，自由按月付费，24小时全年无休，点覆盖广，智能设备个性服务，各种训练模式自由选择； 可能存在的问题123451.包月费用低，那么会造成营收与成本的覆盖问题；2.每个月续费，也缺少了传统健身房盈利的最坚实护城河，以低频养高频；3.免费团课也加重了运营成本，教练体系的培养需要有汰换机制；4.各种人群对于设备需求差异性大，无法有效的做到可复制，还需要兼顾可升级；5.装修与前期开店成本比较大，短期内无法收回成本； 可能的解决办法1231.垂直市场的垂直人流广告，类似于超市的展位推广；2.更多的场地低频时间合作；3.私教的教练培养与汰换机制；]]></content>
      <categories>
        <category>行业认识</category>
      </categories>
      <tags>
        <tag>行业</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus私有库使用部署，与配置相关]]></title>
    <url>%2F2018%2F09%2F29%2Fnexus%E7%A7%81%E6%9C%89%E5%BA%93%E5%B8%A6%E5%9B%BE%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[部署私有库目的 搭建nexus仓库 对于代理仓库没有依赖的情况 对于三方自建仓库管理库的情况 部署私有库目的12针对于在工程中依赖三方库的时候，报出的find in location ，链接实际可用的问题，也针对在三方库莫名的time out的问题；搭建一个私有库，出现问题及时处理及时重启及时管理离线包的方式更能从根本上杜绝这种事情的发生；同时，Nexus在代理远程仓库并且缓存的同时维护本地仓库，节省外网带宽和时间，Nexus私服就可以满足这样的需要。 搭建注意事项搭建一个nexus的私有库，在流程是是比较简单的，麻烦的是调通依赖的代理；下面从自搭建私有库的步骤上来进行一步步引导： * a.安装nexus库服务，使用homebrew安装nexus少了很多繁琐的配置，默认安装的版本是：Nexus Repository Manager OSS 2.14.8-01 * b.nexus服务的管理命令： 服务启动与关闭： nexus start service nexus stop service nexus restart service ({ console | start | stop | restart | status | dump }) * c.配置nexus代理到国内的镜像上： 三种仓库： proxy repository , host repository , virtual repository , group repository;对应 代理仓库，本地仓库，虚拟仓库,仓库组 添加proxy repositroy 仓库到nexus： ![image](so-source-design/blue_blue.jpg) configration 添加 remote storage location 添加 阿里云的国内镜像，根据乐刻工程依赖的情况添加三个依赖仓库： https://maven.aliyun.com/repository/public/ https://maven.aliyun.com/repository/google/ https://maven.aliyun.com/repository/jcenter/ 点击save * d.关闭discovery选项，打开的时候，不在prefix文件配置中的包下载不到,不勾选可以下载该仓库任意的包； * e.本地部署成功之后移植到测试机之后出现 remote access not allowed from M2Repository问题： 将 auto Blocking enabled 设置为false； 原因：nexus私有库，会发送head 和 get 请求到目标代理库，来判断目标代理库是否可用是否健康，未响应或者是响应错误会导致nexus认为目标代理库不可用，会返回这个错误； * f.将本地依赖配置为 respository path //切换到私有库 maven { url &apos;http://maven.leoao.com/nexus/content/repositories/google/&apos; } maven { url &apos;http://maven.leoao.com/nexus/content/repositories/aliyun-public/&apos; } maven { url &apos;http://maven.leoao.com/nexus/content/repositories/jcenter/&apos; } 切换到： maven { url &apos;http://127.0.0.1:8081/nexus/content/repositories/leoao-google/&apos; } maven { url &apos;http://127.0.0.1:8081/nexus/content/repositories/leoao-jcenter/&apos; } maven { url &apos;http://127.0.0.1:8081/nexus/content/repositories/leoao-public/&apos; } 私有库在遍历下载三方依赖的同时，会直接把依赖在本地缓存一份，下次的取用速度会直接先判断私有库是否已有这个版本，已被缓存过的的三方库下载速度会非常快；在三方库的查找上，依照以下的查找顺序来进行： 代理仓库没有依赖在三方的仓库中也没有找到响应的依赖的情况，设置的阿里云三方私有仓库中，未找到的库。按照策略会遍历maven-center,或者谷歌的仓库，同时也会尝试遍历在build.gradle中配置的三方仓库地址；若还是未能找到仓库依赖，还可以手动添加依赖的各项配置直接添加到私有仓库中； 三方自建仓库管理库三方自建仓库对于私有仓库，例如现在的听云依赖仓库为自建仓库，那么在遍历的时候，也会被私有仓库拉下来缓存本地，与其他仓库依赖流程相同；]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>ci相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradientdrawable相关问题]]></title>
    <url>%2F2018%2F09%2F23%2Fgradientdrawable%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 适合在哪种场景使用 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点 解决方案 这个技术解决了什么问题1一个项目中遇到的问题，在使用同drawable的实例，设置其中一个view的backgroundcolor为yellow时候，recycleveiw滚动的时候，造成了其他的item颜色发生问题。下面就讨论下这种情况发生的原因，和避免的方法； 适合在哪种场景使用1当使用git上的statebutton或者是statetextview的时候，不会产生的这个问题，下文我们会探讨一下，为什么同样适用了gradientdrawable的对象，没有让该控件发生这个问题； 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点1用这种方式来实现动态改动背景颜色的方式，原因在于这个标签是不规则的形状，使用了shape的方式来进行设置样式，需要改动shape的背景颜色的时候，只有用gradientdrawable的方式来进行，---（不过引入了statebutton之后，这个问题就不会有了） 1234567891011121314151617181920212223242526从官方的说法上来说：/** * Changes this drawable to use a single color instead of a gradient. * &lt;p&gt; * &lt;strong&gt;Note&lt;/strong&gt;: changing color will affect all instances of a * drawable loaded from a resource. It is recommended to invoke * &#123;@link #mutate()&#125; before changing the color. * * @param argb The color used to fill the shape * * @see #mutate() * @see #setColors(int[]) * @see #getColor */ public void setColor(@ColorInt int argb) &#123; mGradientState.setSolidColors(ColorStateList.valueOf(argb)); mFillPaint.setColor(argb); invalidateSelf(); &#125; 当使用同一个resource的同一个实例来进行背景色管理的时候，改动其中一个颜色那么会影响到其他的背景色，在内存优化上，特别是在recycleview重用机制上来说，都会进行重用，产生随着内存的吃紧而来的问题； 当使用： view获取 GradientDrawable gradientDrawable = (GradientDrawable) viewHolder.mTxtType.getBackground(); gradientDrawable.setColor(color); 的时候，会造成重用； 而在git上的statebutton组件上，也使用gradientdrawable，没有发生这个情况，是因为底层使用的时候，每次的gradientdrawable都重新创建了一次，执行到button的构造方式的时候，都会new一个实例出来。 解决方案1那么我们避免这个问题的方案也大概可以出来了，就是避免掉重用同一个resource出来的drawable实例，而使用创建的实例来进行；可以使用引入组件的方式来简单解决也可以自己建立一个机制，来新建即可；]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>gradientdrawable</tag>
        <tag>工程技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例的设计]]></title>
    <url>%2F2018%2F09%2F17%2Ftest-case-design-xiaozhu%2F</url>
    <content type="text"><![CDATA[测试用例的设计 测试用例的设计 黑盒测试 等价类 边界值 功能测试（页面刷新、用户习惯性使用Tab、Enter等、权限）显示功能性需求 安全性测试 加密（存储、网络传输） 网络传输是否加密 sql注入字符串 同一用户同一终端，多浏览器，登录互斥性 同一用户多终端的浏览器，先后登录互斥性 ‘XSS跨站脚本攻击’，系统行为是否被篡改 多次登录失败，是否阻止暴力破解 兼容性测试 不同浏览器，页面和功能正确 相同浏览器不同版本，页面和功能正确 不同移动设备下浏览器，页面和功能正确 不同分辨率终端，页面和功能正确 性能测试 单用户响应时间小于3s 请求数量是否过多 高并发下响应时间小于5s 高并发下服务器监控指标是否符合预期 高集合点并发场景下，是否存在资源死锁和不合理的资源等待 长时间大量用户，登录登出，服务器端是否存在内存泄漏 网络测试 弱网测试或切换网络或网络延迟如何设计“好的”测试用例 “好的”测试用例必备特征 整体完备性：完全覆盖测试需求 等价类划分的准确性：保证其中一个通过，其他输入也一定测试通过 等价类集合的完备性：所有可能的边界值和边界条件都已经正确识别 三种最常用的测试用例设计方法 等价类划分 有效等价类和无效等价类 边界值分析 正好等于、刚刚大于或刚刚小于 错误推测 基于对被测软件系统设计的理解、过往经验以及个人直觉，推测软件可能的缺陷，从而有针对性的设计测试用例。该方法强调对被测软件的需求理解和对设计实现的细节把握，还有个人的能力。 打造缺陷知识库用例设计的其他经验 深入理解被测软件的架构才能设计出有的放矢的测试用例集，去发现系统边界以及系统集成上的潜在缺陷 必须深入理解被测软件的设计与实现细节，深入理解软件内部的处理逻辑 需要引入需求覆盖率和代码覆盖率来衡量测试执行的完备性，并以此为依据来找出遗漏的测试点 需求合理性测试 测试后的漏测率和问题的严重程度上评估]]></content>
      <categories>
        <category>测试技能</category>
      </categories>
      <tags>
        <tag>理论知识</tag>
        <tag>test用例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试简介]]></title>
    <url>%2F2018%2F09%2F17%2Ftest-case-auto-testcase-summary%2F</url>
    <content type="text"><![CDATA[软件开发生命周期各个阶段的自动化测试技术 软件开发生命周期各个阶段的自动化测试技术1、单元测试的自动化技术 用例框架代码生成的自动化 部分测试输入数据的自动化生成 自动生成边界值 自动桩代码的生成 桩代码（stub code）是用来替代真正代买的临时代码 单元测试开发者只需要关注桩代码内的具体逻辑实现，以及桩代码的返回值 最好还能实现‘抽桩’或拔桩 被测代码的自动化静态分析 常用工具：Sonar、Coverity 测试覆盖率的自动统计与分析2、代码级集成测试的自动化技术 代码级集成测试与单元测试的最大区别：代码级集成测试调用的其他函数都为真实的，不允许使用桩代码代替；单元测试可以；Web Service 测试的自动化技术 Web Service 测试主要指 SOUP API 和 REST API这两类API测试，最典型的是采用SoupUI和Postman等类似的工具，但这种工具一般都是界面手动发起Request并验证Response，难以CI/CD集成，所以出现了API自动化测试框架 代码级API测试用例，一般包括三个步骤： 准备API测试数据 准备调用参数，并调用 验证返回结果 目前JAVA最流行的API测试框架是REST Assured Web Service 还包括： 测试脚手架代码的自动化生成 部分测试输入数据的自动生成 生成遵循边界值原则 Response验证的自动化 关注：返回状态码（state code）、Scheme结构（数据结构）以及具体的字段值 核心思想：自动识别出有差异的字段值，比较过程可以通过规则配置去掉类似：时间戳、会话ID（Session ID）等动态值 基于SoupUI或Postman的自动化脚本生成 开发自动化代码转换生成工具，工具的输入为SoupUI或Postman的测试用例元数据（即JSON元文件），输出为符合API测试框架规范的基于代码实现的测试用例GUI 测试的自动化技术 GUI 自动化测试的两大方向：传统Web浏览器和移动端原生应用（Native App）的GUI自动化 Web浏览器：主流开源方案：Selenium，商业方案：Micro Focus的UFT（前身是HP的QTP） 移动端：主流Appium，IOS集成了XCUITest，Android集成了UIAutomator和Espresso 评论：已有案例：Postman+服务器部署Newman+jenkins 小众全英文（不支持英文）：Katalon Studio jmeter做接口测试 我们现有的API:Python + Selenium + unittest GUI：Python + Appium总结：]]></content>
      <categories>
        <category>测试技能</category>
      </categories>
      <tags>
        <tag>理论知识</tag>
        <tag>自动化测试技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arouter使用阶段性认知]]></title>
    <url>%2F2018%2F09%2F13%2Farouter-thinking%2F</url>
    <content type="text"><![CDATA[arouter 问题总结 values 两种系统识别文件夹，细分三种 有没有改造之法？ arouter 问题总结：123456789101112131415作为一个阿里系的框架，arouter在根本上是实现了，介绍里面所说的，解耦，传参，拦截器，注解，基本的方案实现。在单module中运行也还是可以的，可 能初学者写个把demo之后发现，哎，这阿里系的还是厉害啊。满足要求啊，不过别着急各位，早晚得报到身上的，来自于三方不可控框架造成的问题，或早或晚会给个教训。说好的太多了，我们可以来探讨一下阿里的这个框架的不足；不足一： 对于多个module的完全解耦是带了认知负担的，完全靠直接的信任度来进行保证； arouter最基本的一点是实现字符串作为路由来完成页面-包含activity，fragment页面的跳转，但是也带来了对于其他的模块完全的黑盒问题，不过要是维护者说，这本就是不多的一些妥协，那确实也没什么好说得了，毕竟这是一个在已有框架中总结弊端的文章。这算是其中一个问题，arouter利用编译时注解来生成了，string与class的对应map，每次在router到相应的地址的时候，直接在map中找key，由此拿出对于的类引用，跳转或者是fragmentmanager跳转，确实也是把一些简单代码逻辑重复工作给封装起来。map处理这种的key-value形式的操作，速度也快，确是带来了完全解耦的无管理状态，这会带来什么呢？ 带来问题挺多的，其中下文就会列举一个方面的影响；不足二： 组件化的支持，后期拆分会带来很大问题； 组件化拆分之前，无法知道一个业务会发展出多大的代码库，开始认为不用拆分的库，之后也会走入一个拆分的巷道，那么前期跟后台跟前段约定的路由就会变成一个巨大的负担。解决方案可以用intercepter来进行拦截和转发，当前的工程已经进入了这个怪圈；不足三： 为了拆分，工程做了妥协，在原有的基础上，保留原始的分组；而新分出去的module就需要在interceptor中定义一些转发，同时要插桩，本身也不是不可接受，但是还有一个问题违背了我们拆分组件的初衷。组件之所以拆分就是因为需要划分职责，增加重用的概率，而且就算组建不重用，那么底层的很多公共的页面例如分享，选择照片，选择视频，之内的公共的一些页面可能由于没有上下级依赖需要arouter跳转的时候，都会遇到同一个问题： 作为转发的app层不在了，那么没有中间层进行转发，开始的分组件就变成了，离开中央集权之后就不可通讯的问题； 有没有改造之法？123456改造的方法分为基础上改动和彻底重建两种，各有利弊吧；A.一般成熟的大公司，或者说人力比较充沛的大公司，一般都选择了自己自建一个路由转发系统来绕开对于三方框架的依赖，后期的改动和定制都会成为瓶颈；那么市面上已经使用比较多的几个路由框架分别是，美团+饿了么+阿里都有自己的一套路由框架；B.改造arouter的aop和加载核心： arouter之所以有这个问题，根本原因在于，arouter通过aop生成类来做map映射的时候，是在同一个path中生成了诸多的以group为类名的类，那么肯定就有不同的module不能有相同的分组，问题的关键在于生成的逻辑是依赖group来进行的，同路径的自然不能同类名的； 针对这个限制，我们可以进行修改 改造之后的注意点？1改动比较大一些的框架，基础的框架，随之而来的肯定是要经过大量的验证和测试的，一个大意可能会影响面非常的大；验证自己的逻辑对于老逻辑有没有影响，开发之中一定要遵循开闭原则，对于修改关闭对于扩展开放； 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>arouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从碎片化的技能点到片的解决方案的认知改变]]></title>
    <url>%2F2018%2F09%2F13%2Flearn-structer%2F</url>
    <content type="text"><![CDATA[认知改变 如何进行改变 思考问题 认知改变初涉开发醉心于各种奇技淫巧，各种技能，喜欢堆砌很多技能数，当然这些年还是比较有意思的，毕竟想研究什么就研究什么。python脚本的简洁，h5的火热，java后台的了解，android的深度学习，各种语言方向的研究。 当然这些知识在构建一个行业的解决方案的时候，一样是会其效果的，像业务倒逼着技术的成长，对于知识点构建一个知识结构，可以从开始的知识构建得到经验，但是行业的解决方案，乃至于全行业的通用架构的提炼一直没有得到可以训练。当然在遇到比较体系的问题的时候，没有很优化的方案。 前贤有言：开发中的“坑”是对客观的不了解与不通达的主观妥协，确实忘了是谁说的，但是比较有道理。对一个使用中的三方库与文件的彻底了解再加上java的开源特性，使用三方开源的库与资料在调研充分的情况下，是不会有什么坑的。 如何进行改变上面说道了问题，那么就应该想想如何进行改变，成长总是伴随着不习惯不适应，所以这些改变可能让已经适应了舒适区的比较的不适，但是不适那种坐车晕车的强烈的不适，仅仅是一个像冬天吃一个冰激凌感官刺激体验新奇但是味觉比较的小煎熬的过程。 在接触到一个新的方向知识点的时候，希望能够想想这个点，能够加入到知识树中的哪个层级是解决哪个层级的问题，同时能够知道比之前的解决方案优化在哪，原理能不能探求清楚，能不能给别人讲述出来，在之后的一些场景能不能够适用上去；从来知识，路和书都没有白看的，都会在未来的某个时间，在某个转角探出头来，轻声跟你说你好，我过来看你了。无需多言，沉默，相视。 针对当前的方向如何进行成长当前主要的技能集中在安卓端，之后的方向，大变的可能小，但是按照现在软件市场的情况，不变是不可能的。之前的后端知识也需要在某个时间点直接引发出来。非常大的方向改动，需要非常多的业余时间来进行扩充知识面； 当前方向问题：1.后端，已经从事过，初级水平，还需要很多的项目与锻炼到高级； 2.机器学习与人工智能很想深入，但是可能入门基础准备比较多； 3.大数据处理，对于算法要求比较高，需要有技能储备； 当前已着手：后端有相关项目就投入一下；机器学习训练学习模型可以开始了； 当前方向成长路径技能图谱： https://blog.csdn.net/qq_39331713/article/details/82590218 外围与必须技能： https://mp.weixin.qq.com/s/XREOq821aaY0gwrlwrOQJA 思考问题 这个技术能解决什么问题（why） 比较适合在哪些场景应用（where + when) 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 &gt; 有什么优点和缺点（what） 了解前面的问题后，我才会开始去尝试写写Demo，或者更进一步去应用（How to use） 觉得有兴趣或者其实现很牛逼的情况下，我就去研究一下原理机制，看看源码等 （How it implements） 指导思想就是：从行业解决方案，进一步到技能技术的精深。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程定制输入框是否可输入保留光标定制]]></title>
    <url>%2F2017%2F12%2F10%2Finputbox-forbiddeninput%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 比较适合在哪些场景应用 源码研究过程 最后的方案 效果实现 资源链接 技术解决了什么问题这是一个典型的项目倒逼输入的例子。公司有蓝牙组件的需求，那么衍生出的定制需求也是很正常的。需求需要，输入框在保留光标的时候，同时有禁用键盘和启用键盘的操作。这个功能点的技术开始的诞生就是解决在edittext的控件使用时候，保留光标的时候还要禁用掉键盘的自动弹出(如果自定义键盘是同样这个套路的话，可能会有些问题，需要特殊处理)同时功能需求在有多个edittext时候依旧能够统一控制输入框的弹出软键盘功能。比较适合在哪些场景应用该技术适用于产品的具体场景，也可以稍微摘出来作为一个共用控件使用。 源码研究过程这个需求开始肯定要先看看edittext对于软件盘唤起的操作的源码。在edittext父类textview中找到了123456789/*** Sets whether the soft input method will be made visible when this * TextView gets focused. The default is true. */ @android.view.RemotableViewMethod public final void setShowSoftInputOnFocus(boolean show) &#123; createEditorIfNeeded(); mEditor.mShowSoftInputOnFocus = show; &#125; 方法代码段。但是直接使用调用方法来进行的时候会提示：Call requires API level 21 (current min is 18): android.widget.TextView#setShowSoftInputOnFocus less…android 18版本以上的才能够调用这个方法，为了兼容低版本，同时保证方法可用，想到了用反射来进行调用，处理掉反射的异常。 最后的方案如下：1234567891011121314151617181920212223242526272829303132333435/** * 禁止Edittext弹出软件盘，光标依然正常显示。 */ public void disableShowSoftInput() &#123; softinputSet(false); &#125; /** * 打开Edittext弹出软件盘，光标依然正常显示。 */ public void openShowSoftInput() &#123; softinputSet(true); &#125; public void softinputSet(boolean isShow)&#123; if (android.os.Build.VERSION.SDK_INT &lt;= 10) &#123; this.setInputType(InputType.TYPE_NULL); &#125; else &#123; Class&lt;EditText&gt; cls = EditText.class; Method method; try &#123; method = cls.getMethod(&quot;setShowSoftInputOnFocus&quot;, boolean.class); method.setAccessible(true); method.invoke(this, isShow); &#125; catch (Exception e) &#123; &#125; try &#123; method = cls.getMethod(&quot;setSoftInputShownOnFocus&quot;, boolean.class); method.setAccessible(true); method.invoke(this, isShow); &#125; catch (Exception e) &#123; &#125; &#125; &#125; 来控制整个的输入框的弹出与否 布局中的多个输入框的禁用效果实现实现了单个的效果，那么需要实现多个输入框的效果禁用时候，应该就可以大概看下layout对于这个的支持。因为edittext的软键盘弹出很多时候跟是否有焦点相关联。那么在layout中选取了一个布局进行支持的时候，可以看看这个布局viewgroup对于focus的实现方法和控制方法。直接选取了linearlayout的布局来进行研究。往父级进行浏览，最后跟到了view中去：12345678910111213141516171819202122232425262728293031/** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the previous selectable * item. */ public static final int FOCUS_BACKWARD = 0x00000001; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the next selectable * item. */ public static final int FOCUS_FORWARD = 0x00000002; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the left. */ public static final int FOCUS_LEFT = 0x00000011; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus up. */ public static final int FOCUS_UP = 0x00000021; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the right. */ public static final int FOCUS_RIGHT = 0x00000042; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus down. */ public static final int FOCUS_DOWN = 0x00000082; view 对于子view的focus的标志有以上几种，标志着在子view的焦点的变化。这时候大概可以关注一下focus_down了，见名知意。查阅了官方文档，描述也是如此，是在子view中找到下一个可以获取焦点的位置。那么方案就可以定下来了。 布局中多输入框禁用效果方案在布局中找到当前的获取到焦点的view，同时往上找一个子view或者是往下找一个子viwe即可。实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 光标往下去一个输入组件 */ public void next()&#123; boolean isThis = false; View current = this.findFocus(); ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views )&#123; if(isThis)&#123; isThis = false; view.requestFocus(); return ; &#125; if(current == view)&#123; isThis = true; &#125; &#125; &#125; /** * 光标往上去一个输入组件 */ public void previous()&#123; View current = this.findFocus(); ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(int i = 0 ; i &lt; views.size(); i++)&#123; if(current == views.get(i))&#123; if(i &gt;= 1)&#123; views.get(i-1).requestFocus(); &#125; &#125; &#125; &#125; /** * 禁用子view的软键盘自动弹出 */ public void forbidenAllChildSoftinput()&#123; KeyBoardDisableEditText editText; ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views)&#123; if(view instanceof KeyBoardDisableEditText)&#123; editText = (KeyBoardDisableEditText) view; editText.disableShowSoftInput(); &#125; &#125; &#125; /** * 启用子view的软键盘自动弹出 */ public void startAllChildSoftinput()&#123; KeyBoardDisableEditText editText; ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views)&#123; if(view instanceof KeyBoardDisableEditText)&#123; editText = (KeyBoardDisableEditText) view; editText.openShowSoftInput(); &#125; &#125; &#125; 同时在layout中还开放了一个可以控制布局中所有sorftinput弹出事件的方法。那么定制到这里是可以完全解决问题了的。原理就是通过源码来进行一个hack操作而已。demo可能有用先挂出来： 传送门之大传送之术 传送门之布局控制传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>定制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程通用能力-变体包衍生多个定制工程解决方案(java,res,lib全方位定制问题)]]></title>
    <url>%2F2017%2F11%2F18%2Fproject-productflavor-newproject%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 适合在哪种场景使用 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点 上酸菜，咳咳，上代码例子 这个技术解决了什么问题业务中遇到了一个问题需要定制一个版本给到另外的需求，但是主体的业务逻辑功能不用大动，需要定制的页面就是登录页面与所有的跟本软件相关的主体名称需要全部替换掉，颜色字体，启动页，升级包。本身想要的数据隔离，在后端的评估之后，被舍弃掉了，那么定制的工作都落到了客户端的头上。也算是一个比较好的成长时间，所以欣然接受吧。业务来倒逼输出也是不错的。如果业务需要客户端承担更大的优化与定制，对于个人的成长也是很不错的。哦，有点说教了，还是进入主题吧。从安卓的官方文档中也可以查阅到一些关于变体包的资料，传送门之官方文档中国站传送门当然如果只是官方文档的搬运，是不会有这篇文章的。 适合在哪种场景使用当有需要定制不同的字体(当然现在google可以通过下载字体进行替换),颜色值(也可以通过后台动态的进行切换)，各种启动页，各种登录页，各种主体提示与标志的定制。那么这些改动可能涉及到java源代码的定制，res中string，values，colors的定制，甚至是lib,so库的定制。那么被分支切换与升级合并冲突，每次的不同版本升级折腾的要死要死的你，可以考虑使用一下google的这套东西。 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点关于解决场景中的方法确实不少，条条大路通罗马，上面讲场景的时候，顺带就已经说过了。那么现在可以来说说优缺点吧优点:1.主体的逻辑可以通用2.改动与共通的部分清晰好维护缺点：1.同样要承受一部分的定制之苦 上酸菜，咳咳，上代码例子假设变体工程只有一个，但是相信我，开了这个定制的口子那么后面的事情就不止一个变体能解决的了，两个也不行。我们先讨论只有一个变体的情况：这个配置里，不止有例子该有的配置，还为你们打开了另一个大门，一个完整的公司级项目里面会涉及到的定制也包含在里面了。前面是签名的配置，这个不必多说，是为了下面的变体包不同的签名而存在的，包区分是不是同一个包，能不能被装在同一个手机上，就是通过报名和签名的不同来的，所以这两方面的定制必不可少。往下到productflavor的配置，产生的两个分支，这个名字可以任意复合groovy语言规则的名字都可以，新建之后需要在项目新建一个跟main同级的命名跟分支名相同的文件夹文件夹下面新建需要的定制文件夹main文件夹下有的文件夹都可以新建也都可以定制。那么我们先建这两个文件夹，新建的变体分支在buildvariants中可以进行动态的切换，我们现在在custom的分支下，所以custom的java是加载到编译器的，res是加载过的。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android event 事件分发的一些实用解析与源码分析汇总]]></title>
    <url>%2F2017%2F10%2F09%2Ftouchevent-all%2F</url>
    <content type="text"><![CDATA[前言 事件分发的一些概念 QA 源码链接 前言工程中的一些需求需要定制很多的view，而定制的view如何进行这里不进行展开，但是其中遇到的一个问题足以引起重视，那就是view需要处理action事件(如 down , up , move ,cancle )，而总是出现处理了view的touch事件之后，在对view的onclicklistener监听的时候，监听不到点击事件，开始的处理是在网上查(zhan)找(tie)了下。现在好整以暇，可以看看究竟是什么样的机制让ontouch的事件监听了之后，没有onclicklistener的。或者是自己的使用姿势不对。事件分发的一些概念 事件：用户触摸屏幕产生的点击事件 系统将用户的操作事件包装成了一个motionevent的对象。(包含发生触摸的位置，时间，历史记录，手势动作等) 从源码的区分上来说： MOtionEvent.ACTION_DOWN: 用户按下事件 MotionEvent.ACTION_MOVE: 用户移动手指事件 MotionEvent.ACTION_CANCLE: 非用户操作取消事件 MotionEvent.ACTION_UP: 用户手指抬起事件用户的一次操作的事件列 用户的一次手指从按下到抬起的产生的一系列事件。 事件分发的几个分类window/activity , viewgroup 与 view讨论的事件分发除了是由docview分发的onclicklistener之外的诸如：dispatchevent,onintercepttouchevent,ontouchevent的一些事件，其中： widow/activity:dispatchevent,ontouchevent(没有onintercepttouchevent) viewgroup : dispatchevent,ontouchevent(没有onintercepttouchevent) view : dispatchevent,ontouchevent,onintercepttouchevent 基本的传递顺序是： activity—-&gt; viewgroup —-&gt; view e.g 在有多个viewgroup嵌套的时候，遵循一层一层往下传递的规律。 事件分发相关的方法事件分发在activity,viewgroup,view中传递的基本原则 事件分发QA1.view的事件分发的时候，ontouch拦截返回true/false时候，view的onclicklistener都不响应的问题。首先明白view的onclicklistener事件是docview或者说是acitivity的rootview分发给每个view的，那么首先我们要保证在顶层的activity要能获得事件。上图的分类是有问题的，当我们在view中拦截了ontouchevent的时候，传递的是false的时候，表示我们不处理给到父级来处理，但是在activity中没有接到相应的事件，没有给到onclicklistener点击事件。现象如下： 而当我们放开view的ontouchevent让而调用super的事件，那么会得到相应的结果。会响应view的onclick事件，所以，返回false和返回super是不一样的，对于onclick事件绑定来说，必须要把view的ontouchevent给到super，才能够让docview把事件给到view。 2.在上个实验中我们看到了acitivty中调用了两次的ontouchevent。用户的一次点击实际上是一个action_down和一次action_up组成的，所以，是传递了两个motionevent出来，那么activity–&gt;viewgroup—&gt;view是需要走两次的。 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>event事件解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[so库全解析]]></title>
    <url>%2F2017%2F09%2F18%2Fso-source-design%2F</url>
    <content type="text"><![CDATA[google android系统so库比较多的原因 android cpu架构分类 android如何去寻找so库原理 几个需要明白的概念 大厂对于so架构的一些取舍 总结 google android系统so库比较多的原因 为适配众多的cpu架构，实际就是指令集的区别，在开始从复杂指令集改动到简易指令集的微软架构之后，又分出若干阵营，那么这个地方就不展开了，展开我怕篇幅不太够啊，少年。 android cpu架构分类android 当前支持的七种cpu架构Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI~ABI 应用程序二进制接口(Application binary interface)定义了二进制文件(so库)如何运行在相应的系统上。 每种cpu架构对应着一个ABIarmeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64 android如何去寻找so库原理android如何去寻找so库原理图解 android系统寻找so库的顺序，先区分架构，再去寻找完美适配的架构文件夹，若果找不到继续向兼容的架构寻找，匹配架构成功后，加载这个架构下所有的so到data文件夹中，如果在data中找不到应用中使用到的so库，那么会报异常，so link错误等等，不会再到其他架构中去扫描。 几个需要明白的概念主ABI库主ABI库： 与系统影响本身机器对应的ABI库辅助ABI库： 与系统也支持的ABI对应而，为实现最佳性能，应该提供主abi库 各个架构库支持的ABIX86 ： 可以运行在armeabi/armeabi-v7a 主要的ABI是X86,辅助ABI是armeabi-v7amips: 只定义了主ABI是mips(但是极少用于手机，可以忽略)armeabi-v7a ： 主 armeabi-v7a ， 辅助armeabi 只提供一种架构优缺点只提供一种架构优点：可以减小包的体积缺点： 只提供一种架构，而忽视其他架构，那么会影响到性能和兼容，同时也将丢失掉专门为64位优化的性能。 android找so库对于软件开发影响从根本上来说，系统只会把他区分架构的文件夹整个复制到data目录，那么造成一个问题就是，每个架构的文件夹下都应该是so库的全量，如果三方服务供应商，只给了一个armeabi-v7a 的架构，而工程中准备只放一个armeabi的文件夹来减小包大小，那么应该将v7a中的so库拷贝到armeabi中。 同时在运行在androidstudio工程中的build.gradle defaultConfig 中添加： ndk { abiFilters “armeabi” }在打包中，只包含armeabi的架构。 大厂对于so架构的一些取舍armeabi-v7a : facebook , twitterarmeabi: 淘宝 微信armeabi : 淘票票 还是来一个图来说明这个东西吧，毕竟没图你说个啥啊： 我可以大概算一个总结那么实际中我们的取舍遵从的原则：1.为减小体积，只保留armeabi与armeabi-v7a，一般只保留一个2.若只有一个架构，那么其他架构中的so，保留的文件夹下有有全量。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>so库实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[values在碎片化各种屏幕中的系统加载策略问题探讨及ui适配的选择]]></title>
    <url>%2F2017%2F09%2F15%2F2017-09-15-md%2F</url>
    <content type="text"><![CDATA[android寻找资源策略 values 两种系统识别文件夹，细分三种 几种方式系统加 android寻找资源策略 values 两种系统识别文件夹，细分三种values-XXXXxXXXX values-swXXXdp (values-hXXXdp values-wXXXdp)三种系统识别的文件夹命令分别是指定分辨率，适配优先宽度，宽高适配 几种方式系统加载策略的探索项目中使用到了多个values来进行适配的问题，想从根本上弄清楚系统在加载的时候，对文件夹取用策略的判断问题，用实际例子对比了一下swXXXdp与values-1920X1080和默认的values的加载其中的策略指定问题，混合模式下，系统对values的取用问题。ok，开始吧。 添加values-1790X1080,values-1794X1076,values-1794X1080与values-sw361dp前三个文件夹用来对比在跟屏幕真实分辨率相差一些数值的时候，系统会加载那个文件夹下的配置。先用三个文件夹运行，观察结果： 加载了，values-sw361dp 当然是运行的完美契合的那个分辨率了，那么当我们在实际开发的时候，屏幕碎片化太大的时候，这种情况是可遇不可求的，故而需要去测试系统对与不完美契合的情况的处理，删除掉完美契合文件夹： 删除掉之后 运行结果是： 1920X1148 加载到了1920X1148的values，那么说明在 1916X1152 与 1920X1148两个相近的宽高差值相同的文件夹中选择了高来进行优先选择，但是不能排除系统是把第一参数进行对比，而不是将values的匹配高进行优先匹配的，好吧，下面验证一下：改名为： 删除资源 运行结果： 加载的还是高匹配高的那个文件夹，那么结论：系统对不能完美匹配的values文件，遵循的是，宽高差值绝对值进行对比，如果宽高对于当前屏幕分辨率差值小的进行加载，如果当宽高绝对值差值相同的时候，以高匹配度高的values进行加载。上面对比了在使用px来区分values的一些加载规则，那么当swXXXdp出现的时候，(sw—-small width)小宽度概念，当系统的宽度dp值大于该值的时候，加载这套设置。问题在于dp与px方式同时出现的时候，系统对于优先级的判定问题。下面进行判定：加入混合的值文件夹： 运行结果： 算是一个小总结google还是对dp情有独钟啊，1152/3= 384dp跟360还差那么多，要是在一个水平线上来进行对比的话，真真的应该加载1920X1152啊，完美适配的呢，说好的做彼此的天屎的，呸，天屎，算了。但是不管google怎么优先级，从细分上来说，如果是为了适配smartbar这个坑的话，一般来说，用px的values-1920X1152方式来进行细分适配要更加的精确，更能完美处理掉这个问题，毕竟还是在同一个水平上来处理的。但是官方是推sw-XXXdp的。综上所述：values-swXXXdp &gt; values-XXXXxXXXX &gt; values ;注： values-XXXXXxXXXXX 方式的时候，通过宽高跟屏幕分辨率的差值绝对值来进行对比，优先高。好吧，可能有人在等源码，我一起放上来吧 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>values实战</tag>
      </tags>
  </entry>
</search>
