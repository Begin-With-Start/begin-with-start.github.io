<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安卓存储方式完全讲解]]></title>
    <url>%2F2019%2F01%2F23%2Fandroid-datasave-type%2F</url>
    <content type="text"><![CDATA[文件存储方式 android 中的存储 名称 速度 安全性 多线程支持 文件 慢 (私有文件外)否 读写现成不安全 数据库 快 安全 由sqlite database保证线程安全 ContentProvider 视底层数据存储而定 安全 过程线程安全 shareprefrence 慢(转存到xml中为止) private安全 不安全 mmkv 快 可控 安全 1各种存储方式根据特性，可以在需要的时候进行选择；没有一种存储方式适用于所有的情况；只能根据业务和功能的需求，选择合适的存储方式； 文件存储方式12文件的存储，指在安卓系统中，以文件方式放在内部存储或者外部存储的方式；文件存储可以存放比较大的数据，图片，视频，同时对于大量的android运行日志，dump日志，apk，临时碎片推荐使用文件的方式，根据所存储文件的安全性要求和文件存储位置要求来选择合适的存储位置文件存储位置分为两种：内部存储，外部存储两种； （内部存储）路径 存储内容 api data/data/包名/shared_prefs 存储sp文件 .. data/data/包名/databases 数据库文件 .. data/data/包名/files 文件存储 context.getFilesDir() data/data/包名/cache 缓存 context.getCacheDir() （外部存储 mnt/storage ）路径 存储内容 api 九大公用存储+sd卡目录 存储sp文件 .. 私有目录 storage/sdcard/android/data/包名/file 文件 context.getExternalFilesDir(Environment.DIRECTORY_MUSIC) 私有目录 storage/sdcard/android/data/包名/file 缓存 context.getExternalFilesDir() 方法 路径 /storage/sdcard0/Alarms Environment.getExternalStoragePublicDirectory(DIRECTORY_ALARMS) /storage/sdcard0/DCIM Environment.getExternalStoragePublicDirectory(DIRECTORY_DCIM) /storage/sdcard0/Download Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS) /storage/sdcard0/Movies Environment.getExternalStoragePublicDirectory(DIRECTORY_MOVIES) /storage/sdcard0/Music Environment.getExternalStoragePublicDirectory(DIRECTORY_MUSIC) /storage/sdcard0/Notifications Environment.getExternalStoragePublicDirectory(DIRECTORY_NOTIFICATIONS) /storage/sdcard0/Pictures Environment.getExternalStoragePublicDirectory(DIRECTORY_PICTURES) /storage/sdcard0/Podcasts Environment.getExternalStoragePublicDirectory(DIRECTORY_PODCASTS) /storage/sdcard0/Ringtones Environment.getExternalStoragePublicDirectory(DIRECTORY_RINGTONES) 1在路径中带了包名的代码访问需要使用context需要使用上下文，没有带包名的，可以直接使用enviroment的方法进行访问； 数据库123```![image](android-newplatform-adaptation-md/google_apisdk_permission.jpg)## 工程中已经发现需要注意的三方库 ## 详细分析： http://kuaibao.qq.com/s/20180327G17Y3L00?refer=spider 扫描工具： 链接: https://pan.baidu.com/s/1J6ZvwWt16imoWoODY7dWXA 提取码: 29yy]]></content>
      <categories>
        <category>android技能,存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vysor共享手机屏幕高清破解]]></title>
    <url>%2F2019%2F01%2F21%2Fandroid-vysor-chrome-plugin%2F</url>
    <content type="text"><![CDATA[chrome 插件vysor高清模式破解 vysor共享手机屏幕破解123456789101112131415chrome插件都是本地的js脚本，验证和校验是否是有效用户有V权限用户，都在本地是可以进行本地破解的；首先下载vysor插件 [官网](http://www.vysor.io/)安装完成后,打开用chrome打开 chrome://version/ 查看 个人资料路径例子: /Users/XXX/Library/Application Support/Google/Chrome/Default之后进入Extensions文件夹 找到gid带头的文件夹 里面就是插件的目录之后打开uglify.js 为了更直观的修改最好格式化下需要更改两个地方:第一个:首先查找_il 直接将后面改成true ;作者可能会重新打包所以后面的内容可能会有变动;目前我的是 _il:We.a();第二个:查找&quot;Account Management&quot;将上面的三个变量的值 都改成1;目前我的是: var e, t = !1,o = !1,都改成 var e = 1, t = 1,o = 1,之后从打开vysor:chrome://apps/看到变成了vysor pro就表示成功了。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《行动变现》 读书笔记]]></title>
    <url>%2F2018%2F12%2F09%2Freading-book-tag-1-20181209%2F</url>
    <content type="text"><![CDATA[《行动变现》 第二章 决定你未来的三架马车 《行动变现》 第三章 《让目标来有效的管理时间》 《行动变现》 第二章 决定你未来的三架马车123456789《掌握专业能力，生活将不一样》1.预期管理：不再开始的时候提高期望层级，而是适当留出一部分合适的缓冲时间；2.写作技能是通用技能，不管是什么职级什么岗位，能说与能写一定要相互结合来做；3.工作中： 需要有统览全局的思维，而不是接手开始就埋头工作，知道你的业务方核心关注点在哪哪些又是下游发散出来影响你工期工作的点，尽量规避；4.在工作中，可以以图表，文字记录的东西尽量整理出架构，可以方便别人使用，同事也能更好的了解全局情况，也是在工作中差异化的东西，可以突出不同；《一定告诉别人你很值钱》1.明码标价自己的剩余时间，也对其他专业人才给出回报，可以得到更加专业的结果。不能把自己的时间贱卖了，收费会过滤80%的请求但是会剩20%的付费用户，而这20%用户还会带来更多的机会； 不用出卖的时间可以拿来做自己 想做的事情，而不用困于琐事当中； 第三章 《让目标来有效的管理时间》12345678910《如何有效的管理你的时间》1.不推荐写满自己的时间表，不用强制某个点完成什么，但是可限定每天完成什么，并且空闲下来换脑子之后就需要进入下一项日程中。2.不要高估自己的效率，任何事情都需要前置项，充分考虑，再给出估算时间更加靠谱；3.剩余时间的剩余价值问题，万事开头一般会有一个结果，一般的没有时间说明事情被排到了不紧急同时不重要的象限中；4.整块时间来做整块事情或是相近的事情，避免在事情中频繁切换带来的消耗，这与之前说的番茄工作法相违背，而微信与钉钉的碎片化切割也会降低效率，番茄仔认知里面可以相似的认为是符合大众的小白班和小白课堂，是针对对于初级学渣而设置的规则适用于所有人，那么必然是一个易接受的程度；《相信复利的力量》复利： 指一笔资产在下一个计息周期内，上一期的利息也计算利息，也就是“上期本息，作为下期本金”1.坚持去做一件事，持续做，最后会获得超越预期的成果；2.以坚持的时候不要跟365天都一样的人讨论看法，而应该看齐在自我要求高在行业不错的人。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>行动变现</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android9.0适配的前世今生]]></title>
    <url>%2F2018%2F10%2F29%2Fandroid-newplatform-adaptation-md%2F</url>
    <content type="text"><![CDATA[andorid 9.0 渐进的改进方式 sdk检查原理 工程中已经发现需要注意的三方库 andorid 9.012google终于开始解决悬在自己头上的达摩斯之剑了，安全+卡顿两个被诟病的地方；这次在nogout的p升级上，开始对sdk中被各大厂商和黑科技玩坏的反射和对底层的各种调用问题开始着手解决；这个版本对于非sdk暴露api方法做了限制，不论是调用，反射还是jni，提升自己的兼容性；对限制的接口进行调用的时候，会奔溃或者弹窗或者弹出toast警告的方式来一个版本一个版本的把非法的sdk调用消灭掉； 渐进的改进方式1对于sdk的限制，google出了几个列表，blacklist，dark-graylist， light-graylist；处理方式也有不同，对于黑名单这个版本必须改动，不然会带来奔溃；dark-graylist的接口，为p版本的时候不准调用，小于p的手机可调用，会警告；light-graylist的在》=p的版本的时候会进行警告，后续版本会移动到深灰列表中； sdk检查原理123456789101112131415161718192021222324252627282930313233343536373839start 准备阶段： 在c层对androidsdk的api权限进行检测从编译期的几个api列表中开始： LOCAL_LIGHT_GREYLIST := $(INTERNAL_PLATFORM_HIDDENAPI_LIGHT_GREYLIST) LOCAL_DARK_GREYLIST := $(INTERNAL_PLATFORM_HIDDENAPI_DARK_GREYLIST) LOCAL_BLACKLIST := $(INTERNAL_PLATFORM_HIDDENAPI_BLACKLIST) # File names of source files we will use to generate the final API lists. LOCAL_SRC_GREYLIST := frameworks/base/config/hiddenapi-light-greylist.txt LOCAL_SRC_VENDOR_LIST := frameworks/base/config/hiddenapi-vendor-list.txt LOCAL_SRC_FORCE_BLACKLIST := frameworks/base/config/hiddenapi-force-blacklist.txt LOCAL_SRC_PUBLIC_API := frameworks/base/config/hiddenapi-public-dex.txt LOCAL_SRC_PRIVATE_API := frameworks/base/config/hiddenapi-private-dex.txt LOCAL_SRC_REMOVED_API := frameworks/base/config/hiddenapi-removed-dex.txt 在定义light-greylist，black-list，dark-greylist中可以看出，系统开始就存储了两个列表hiddenapi-blacklist.txt，hiddenapi-dark-greylist.txt来源于Framework/base/config目录，而light-greylist来自于private-list减去dark-list和black-list表的并集之后的结果集；1.遍历class.dex中的函数或者字段列表 按照： HiddenApiAccessFlags::kWhitelist =&gt; 0b00 hiddenapi-light-greylist.txt=&gt; HiddenApiAccessFlags::kLightGreylist =&gt; 0b01 hiddenapi-dark-greylist.txt =&gt; HiddenApiAccessFlags::kDarkGreylist=&gt; 0b10 hiddenapi-blacklist.txt =&gt; HiddenApiAccessFlags::kBlacklist =&gt; 0b11 的对应表将数值写入到ClassDataMethod/ClassDataField结构体中成员access_flags_原始值进行处理后重新写入2.最后一步，重新校验dex头部签名 Hiddenapi处理后，完成从3个文本文件数据与原始dex格式文件的合并，即生成新的dex。3.Art Runtime时期 将 access_flags_转换为需要的值； hiddenapi-light-greylist.txt (0b01) hiddenapi-dark-greylist.txt (0b10) hiddenapi-blacklist.txt (0b11) 将转换之后的2进制值再存入进去，等待在运行期再使用；4.运行期：在app运行时，会校验artmethod结构体中access_flags_最高2位的值，校验的手段包括直接调用、反射、JNI获取 0(0b00) kAllow直接放过 1(0b01) kAllowButWarn放过，但日志警告 2(0b10) kAllowButWarnAndToast放过，且日志警告和弹窗 3(0b11) kDeny拒绝那么在用户和开发层面表现出来的现象就是： 工程中已经发现需要注意的三方库1作为一个已经运行了三年的工程在项目里面不可避免的引入了一些对于google不太友好的sdk进来，现在发现的是tinker和gson的低版本会造成引入比较多的非法sdkapi不过可以通过升级到最新的三方版本来进行规避； 其他很奇怪的开发版造成的适配问题123456789101112131415161718192021222324252627// Android 9.0 限制了开发者调用非官方公开API方法或接口, 关闭警告弹框private void closeAndroidPDialog()&#123; try &#123; Class clazz = Class.forName(&quot;android.content.pm.PackageParser$Package&quot;); Constructor constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; Class clazz = Class.forName(&quot;android.app.ActivityThread&quot;); Method method = clazz.getDeclaredMethod(&quot;currentActivityThread&quot;); method.setAccessible(true); Object object = method.invoke(null); Field filed = clazz.getDeclaredField(&quot;mHiddenApiWarningShown&quot;); filed.setAccessible(true); filed.setBoolean(object, true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;这种方式不推荐使用，只是在最终的适配也无法满足的 mix 2s 开发版 9.0 时候特定的适配问题添加下； 详细分析： http://kuaibao.qq.com/s/20180327G17Y3L00?refer=spider 扫描工具： 链接: https://pan.baidu.com/s/1J6ZvwWt16imoWoODY7dWXA 提取码: 29yy]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gson与fastjson选取与部分原理解答]]></title>
    <url>%2F2018%2F10%2F11%2Fgson-project-reconfigratijon%2F</url>
    <content type="text"><![CDATA[项目中使用了多个解析库的时候，总会遇到一些取舍，那么我们可以从原理和解析速度上面来进行取舍，同时提高基础库的了解，便于今后对库进行改动和提升操作，下面就一起来讨论一下json的序列化和反序列化库的一些区别，探讨一些库的原理； gson fastjson jackson1234567891011121314151617gson fastjson jackson 三者都可以用来进行对象的序列化与反序列化操作，三者的速度对别，摘录下别人的结果，真实的结果估计也差不多，控制一下单一变量原则，对于各个序列方式擅长的方面，其实在开发中遇到的概率暂时不考虑；序列化时间对比：类库 样本数量 执行次数 最长时间(毫秒) 最短时间(毫秒) 平均时间(毫秒)FastJSON 100000 10 2291.22 1416.70 1454.93Jackson 100000 10 1980.92 841.91 880.82Gson 100000 10 2383.02 1469.08 1520.38反序列化对比：类库 样本数量 执行次数 最长时间(毫秒) 最短时间(毫秒) 平均时间(毫秒)FastJSON 100000 10 7942.31 340.55 6526.41Jackson 100000 10 7957.22 6623.85 6815.41Gson 100000 10 8235.15 7006.06 7364.75从序列化和反序列化的表现来看，三种方案速度相差不是很大，所以在项目中已经使用了fastjson作为业务解析，gson用在了底层解析的时候，应该直接选取其中一种解析方式即可，不需要凭空在引进集中方案来增加包体积; gson与fastjson12两种序列化方案是不应该放到一起的，毕竟对于速度相差不多，在不考虑易用性的时候，其实何种解析方案都可；鉴于gson被放到了网络底层来进行了数据的解析，那么我们最终选择了gson来进行序列化，而且渐渐是需要移除掉fastjson的依赖的；下面简单对比一下fastjson和gson在原理上的差异； gson解析原理： ![image](gson-project-reconfigratijon/gson_show_main_flow.jpg) 1gson主要是通过遍历json和对象中的字段，遍历json进行类型判断，调取响应的TypeAdapter对象，再去bean中找到相对应的字段name生成一个boundfield，后续通过typeadapter进行数值的存入操作；直到解析结束，形成一个javabean，那么我们很容易就找到了gson会发生错误的最根本原因，在循环阶段就已经判断出来的字段类型，获取到bean中对应的typeadapter之后，尝试进行类型的转换时候，类型转换失败，自然会报出gson的一个自定义异常JsonSyntaxException，这个异常主要是针对于在类型强转过程中，统一catch之后，包装到自定义异常类中抛给调用方； 12fastjson解析原理：基于反射，在解析过程中，经过预测算法优化，加上各种缓存来提升速度； json解析取舍1两种解析在根本上，速度不会相差太大，那么只需要保留一种解析即可，没有必要维护多个库，gson已经被使用到了网络库的底层中，那么最方便的方式就是去掉fastjson的解析库；只保留gson的解析方式；]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>gson重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus私有库使用部署，与配置相关]]></title>
    <url>%2F2018%2F09%2F29%2Fnexus%E7%A7%81%E6%9C%89%E5%BA%93%E5%B8%A6%E5%9B%BE%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[部署私有库目的 搭建nexus仓库 对于代理仓库没有依赖的情况 对于三方自建仓库管理库的情况 部署私有库目的12针对于在工程中依赖三方库的时候，报出的find in location ，链接实际可用的问题，也针对在三方库莫名的time out的问题；搭建一个私有库，出现问题及时处理及时重启及时管理离线包的方式更能从根本上杜绝这种事情的发生；同时，Nexus在代理远程仓库并且缓存的同时维护本地仓库，节省外网带宽和时间，Nexus私服就可以满足这样的需要。 搭建注意事项搭建一个nexus的私有库，在流程是是比较简单的，麻烦的是调通依赖的代理；下面从自搭建私有库的步骤上来进行一步步引导： * a.安装nexus库服务，使用homebrew安装nexus少了很多繁琐的配置，默认安装的版本是：Nexus Repository Manager OSS 2.14.8-01 * b.nexus服务的管理命令： 服务启动与关闭： nexus start service nexus stop service nexus restart service ({ console | start | stop | restart | status | dump }) * c.配置nexus代理到国内的镜像上： 三种仓库： proxy repository , host repository , virtual repository , group repository;对应 代理仓库，本地仓库，虚拟仓库,仓库组 添加proxy repositroy 仓库到nexus： ![image](so-source-design/blue_blue.jpg) configration 添加 remote storage location 添加 阿里云的国内镜像，根据乐刻工程依赖的情况添加三个依赖仓库： https://maven.aliyun.com/repository/public/ https://maven.aliyun.com/repository/google/ https://maven.aliyun.com/repository/jcenter/ 点击save * d.关闭discovery选项，打开的时候，不在prefix文件配置中的包下载不到,不勾选可以下载该仓库任意的包； * e.本地部署成功之后移植到测试机之后出现 remote access not allowed from M2Repository问题： 将 auto Blocking enabled 设置为false； 原因：nexus私有库，会发送head 和 get 请求到目标代理库，来判断目标代理库是否可用是否健康，未响应或者是响应错误会导致nexus认为目标代理库不可用，会返回这个错误； * f.将本地依赖配置为 respository path //切换到私有库 maven { url &apos;http://maven.leoao.com/nexus/content/repositories/google/&apos; } maven { url &apos;http://maven.leoao.com/nexus/content/repositories/aliyun-public/&apos; } maven { url &apos;http://maven.leoao.com/nexus/content/repositories/jcenter/&apos; } 切换到： maven { url &apos;http://127.0.0.1:8081/nexus/content/repositories/leoao-google/&apos; } maven { url &apos;http://127.0.0.1:8081/nexus/content/repositories/leoao-jcenter/&apos; } maven { url &apos;http://127.0.0.1:8081/nexus/content/repositories/leoao-public/&apos; } 私有库在遍历下载三方依赖的同时，会直接把依赖在本地缓存一份，下次的取用速度会直接先判断私有库是否已有这个版本，已被缓存过的的三方库下载速度会非常快；在三方库的查找上，依照以下的查找顺序来进行： 代理仓库没有依赖在三方的仓库中也没有找到响应的依赖的情况，设置的阿里云三方私有仓库中，未找到的库。按照策略会遍历maven-center,或者谷歌的仓库，同时也会尝试遍历在build.gradle中配置的三方仓库地址；若还是未能找到仓库依赖，还可以手动添加依赖的各项配置直接添加到私有仓库中； 三方自建仓库管理库三方自建仓库对于私有仓库，例如现在的听云依赖仓库为自建仓库，那么在遍历的时候，也会被私有仓库拉下来缓存本地，与其他仓库依赖流程相同；]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>ci相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身行业认识]]></title>
    <url>%2F2018%2F09%2F29%2Ftrade-healthy-knowledge%2F</url>
    <content type="text"><![CDATA[健身行业 公司正在做的事情 可能存在的问题 可能的解决办法 健身行业123456健身行业的现在玩家分为： 1.团操-超级星星 2.私教 3.户外跑-光猪跑，彩色跑各种跑 4.传统健身房-买年卡吸用户 5.线上运动方向-keep 12对于行业内的一些问题，也都有各自的解决方案，从健身门槛过高，开始的传统健身房通过年卡这种比较重的方式，通过低频用户来养高频和场地费用换取利润的方式，对于90后来说过于重了些，传统健身房在新兴的健身房铺量的打击下会渐渐失去新生代用户，而失去年轻一代就代表失去未来。年轻一代的不固定性，常变的生活状态，处于工作生活甚至还要加上学校的几地生活状态，在一个单个健身房办卡无法通用，时间无法满足的情况会变得越来越难忍受。年轻人需要的是，短期-密度-方便-便宜。keep在一定的程度上满足了轻量，短期，场地实用性大，灵活，年轻态的需求，不过处于健身需求升级的人必然会寻求另外的专业的场地和器材，大肌霸这样的程度健身是无法在小场地小器材上满足的。 公司正在做的事情1234567891011线上： 1.提供一个可以自由约课，自由上课，自由锻炼的平台，7X24小时的服务，全国十城通用的月卡，更加轻量。 2.提供适用于全国的活动，单个城市区分度的活动，刺激运动的欲望。 3.提供专业的设备，测试身体的当前状态，比传统的教练用目测更加科学可信。应该明白用肉眼无法触达到骨骼肌含量，无法知道体脂含量； 4.提供教练的成长平台，关注教练的成长与教育，关注用户的体验反馈；线下： 1.建设大量的场馆，提供多的健身设备，适用于更多的健身需求； 2.配备私教区域 ， 认证私教可随时到场教授课程； 3.配备团操区域，让用户能上更多的免费，收费的私教，更多选择；总说：首家99元包月，月单场地百余节课程，自由按月付费，24小时全年无休，点覆盖广，智能设备个性服务，各种训练模式自由选择； 可能存在的问题123451.包月费用低，那么会造成营收与成本的覆盖问题；2.每个月续费，也缺少了传统健身房盈利的最坚实护城河，以低频养高频；3.免费团课也加重了运营成本，教练体系的培养需要有汰换机制；4.各种人群对于设备需求差异性大，无法有效的做到可复制，还需要兼顾可升级；5.装修与前期开店成本比较大，短期内无法收回成本； 可能的解决办法1231.垂直市场的垂直人流广告，类似于超市的展位推广；2.更多的场地低频时间合作；3.私教的教练培养与汰换机制；]]></content>
      <categories>
        <category>行业认识</category>
      </categories>
      <tags>
        <tag>行业</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradientdrawable相关问题]]></title>
    <url>%2F2018%2F09%2F23%2Fgradientdrawable%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 适合在哪种场景使用 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点 解决方案 这个技术解决了什么问题1一个项目中遇到的问题，在使用同drawable的实例，设置其中一个view的backgroundcolor为yellow时候，recycleveiw滚动的时候，造成了其他的item颜色发生问题。下面就讨论下这种情况发生的原因，和避免的方法； 适合在哪种场景使用1当使用git上的statebutton或者是statetextview的时候，不会产生的这个问题，下文我们会探讨一下，为什么同样适用了gradientdrawable的对象，没有让该控件发生这个问题； 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点1用这种方式来实现动态改动背景颜色的方式，原因在于这个标签是不规则的形状，使用了shape的方式来进行设置样式，需要改动shape的背景颜色的时候，只有用gradientdrawable的方式来进行，---（不过引入了statebutton之后，这个问题就不会有了） 1234567891011121314151617181920212223242526从官方的说法上来说：/** * Changes this drawable to use a single color instead of a gradient. * &lt;p&gt; * &lt;strong&gt;Note&lt;/strong&gt;: changing color will affect all instances of a * drawable loaded from a resource. It is recommended to invoke * &#123;@link #mutate()&#125; before changing the color. * * @param argb The color used to fill the shape * * @see #mutate() * @see #setColors(int[]) * @see #getColor */ public void setColor(@ColorInt int argb) &#123; mGradientState.setSolidColors(ColorStateList.valueOf(argb)); mFillPaint.setColor(argb); invalidateSelf(); &#125; 当使用同一个resource的同一个实例来进行背景色管理的时候，改动其中一个颜色那么会影响到其他的背景色，在内存优化上，特别是在recycleview重用机制上来说，都会进行重用，产生随着内存的吃紧而来的问题； 当使用： view获取 GradientDrawable gradientDrawable = (GradientDrawable) viewHolder.mTxtType.getBackground(); gradientDrawable.setColor(color); 的时候，会造成重用； 而在git上的statebutton组件上，也使用gradientdrawable，没有发生这个情况，是因为底层使用的时候，每次的gradientdrawable都重新创建了一次，执行到button的构造方式的时候，都会new一个实例出来。 解决方案1那么我们避免这个问题的方案也大概可以出来了，就是避免掉重用同一个resource出来的drawable实例，而使用创建的实例来进行；可以使用引入组件的方式来简单解决也可以自己建立一个机制，来新建即可；]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>gradientdrawable</tag>
        <tag>工程技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试用例的设计]]></title>
    <url>%2F2018%2F09%2F17%2Ftest-case-design-xiaozhu%2F</url>
    <content type="text"><![CDATA[测试用例的设计 测试用例的设计 黑盒测试 等价类 边界值 功能测试（页面刷新、用户习惯性使用Tab、Enter等、权限）显示功能性需求 安全性测试 加密（存储、网络传输） 网络传输是否加密 sql注入字符串 同一用户同一终端，多浏览器，登录互斥性 同一用户多终端的浏览器，先后登录互斥性 ‘XSS跨站脚本攻击’，系统行为是否被篡改 多次登录失败，是否阻止暴力破解 兼容性测试 不同浏览器，页面和功能正确 相同浏览器不同版本，页面和功能正确 不同移动设备下浏览器，页面和功能正确 不同分辨率终端，页面和功能正确 性能测试 单用户响应时间小于3s 请求数量是否过多 高并发下响应时间小于5s 高并发下服务器监控指标是否符合预期 高集合点并发场景下，是否存在资源死锁和不合理的资源等待 长时间大量用户，登录登出，服务器端是否存在内存泄漏 网络测试 弱网测试或切换网络或网络延迟如何设计“好的”测试用例 “好的”测试用例必备特征 整体完备性：完全覆盖测试需求 等价类划分的准确性：保证其中一个通过，其他输入也一定测试通过 等价类集合的完备性：所有可能的边界值和边界条件都已经正确识别 三种最常用的测试用例设计方法 等价类划分 有效等价类和无效等价类 边界值分析 正好等于、刚刚大于或刚刚小于 错误推测 基于对被测软件系统设计的理解、过往经验以及个人直觉，推测软件可能的缺陷，从而有针对性的设计测试用例。该方法强调对被测软件的需求理解和对设计实现的细节把握，还有个人的能力。 打造缺陷知识库用例设计的其他经验 深入理解被测软件的架构才能设计出有的放矢的测试用例集，去发现系统边界以及系统集成上的潜在缺陷 必须深入理解被测软件的设计与实现细节，深入理解软件内部的处理逻辑 需要引入需求覆盖率和代码覆盖率来衡量测试执行的完备性，并以此为依据来找出遗漏的测试点 需求合理性测试 测试后的漏测率和问题的严重程度上评估]]></content>
      <categories>
        <category>测试技能</category>
      </categories>
      <tags>
        <tag>理论知识</tag>
        <tag>test用例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试简介]]></title>
    <url>%2F2018%2F09%2F17%2Ftest-case-auto-testcase-summary%2F</url>
    <content type="text"><![CDATA[软件开发生命周期各个阶段的自动化测试技术 软件开发生命周期各个阶段的自动化测试技术1、单元测试的自动化技术 用例框架代码生成的自动化 部分测试输入数据的自动化生成 自动生成边界值 自动桩代码的生成 桩代码（stub code）是用来替代真正代买的临时代码 单元测试开发者只需要关注桩代码内的具体逻辑实现，以及桩代码的返回值 最好还能实现‘抽桩’或拔桩 被测代码的自动化静态分析 常用工具：Sonar、Coverity 测试覆盖率的自动统计与分析2、代码级集成测试的自动化技术 代码级集成测试与单元测试的最大区别：代码级集成测试调用的其他函数都为真实的，不允许使用桩代码代替；单元测试可以；Web Service 测试的自动化技术 Web Service 测试主要指 SOUP API 和 REST API这两类API测试，最典型的是采用SoupUI和Postman等类似的工具，但这种工具一般都是界面手动发起Request并验证Response，难以CI/CD集成，所以出现了API自动化测试框架 代码级API测试用例，一般包括三个步骤： 准备API测试数据 准备调用参数，并调用 验证返回结果 目前JAVA最流行的API测试框架是REST Assured Web Service 还包括： 测试脚手架代码的自动化生成 部分测试输入数据的自动生成 生成遵循边界值原则 Response验证的自动化 关注：返回状态码（state code）、Scheme结构（数据结构）以及具体的字段值 核心思想：自动识别出有差异的字段值，比较过程可以通过规则配置去掉类似：时间戳、会话ID（Session ID）等动态值 基于SoupUI或Postman的自动化脚本生成 开发自动化代码转换生成工具，工具的输入为SoupUI或Postman的测试用例元数据（即JSON元文件），输出为符合API测试框架规范的基于代码实现的测试用例GUI 测试的自动化技术 GUI 自动化测试的两大方向：传统Web浏览器和移动端原生应用（Native App）的GUI自动化 Web浏览器：主流开源方案：Selenium，商业方案：Micro Focus的UFT（前身是HP的QTP） 移动端：主流Appium，IOS集成了XCUITest，Android集成了UIAutomator和Espresso 评论：已有案例：Postman+服务器部署Newman+jenkins 小众全英文（不支持英文）：Katalon Studio jmeter做接口测试 我们现有的API:Python + Selenium + unittest GUI：Python + Appium总结：]]></content>
      <categories>
        <category>测试技能</category>
      </categories>
      <tags>
        <tag>理论知识</tag>
        <tag>自动化测试技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arouter使用阶段性认知]]></title>
    <url>%2F2018%2F09%2F13%2Farouter-thinking%2F</url>
    <content type="text"><![CDATA[arouter 问题总结 values 两种系统识别文件夹，细分三种 有没有改造之法？ arouter 问题总结：123456789101112131415作为一个阿里系的框架，arouter在根本上是实现了，介绍里面所说的，解耦，传参，拦截器，注解，基本的方案实现。在单module中运行也还是可以的，可 能初学者写个把demo之后发现，哎，这阿里系的还是厉害啊。满足要求啊，不过别着急各位，早晚得报到身上的，来自于三方不可控框架造成的问题，或早或晚会给个教训。说好的太多了，我们可以来探讨一下阿里的这个框架的不足；不足一： 对于多个module的完全解耦是带了认知负担的，完全靠直接的信任度来进行保证； arouter最基本的一点是实现字符串作为路由来完成页面-包含activity，fragment页面的跳转，但是也带来了对于其他的模块完全的黑盒问题，不过要是维护者说，这本就是不多的一些妥协，那确实也没什么好说得了，毕竟这是一个在已有框架中总结弊端的文章。这算是其中一个问题，arouter利用编译时注解来生成了，string与class的对应map，每次在router到相应的地址的时候，直接在map中找key，由此拿出对于的类引用，跳转或者是fragmentmanager跳转，确实也是把一些简单代码逻辑重复工作给封装起来。map处理这种的key-value形式的操作，速度也快，确是带来了完全解耦的无管理状态，这会带来什么呢？ 带来问题挺多的，其中下文就会列举一个方面的影响；不足二： 组件化的支持，后期拆分会带来很大问题； 组件化拆分之前，无法知道一个业务会发展出多大的代码库，开始认为不用拆分的库，之后也会走入一个拆分的巷道，那么前期跟后台跟前段约定的路由就会变成一个巨大的负担。解决方案可以用intercepter来进行拦截和转发，当前的工程已经进入了这个怪圈；不足三： 为了拆分，工程做了妥协，在原有的基础上，保留原始的分组；而新分出去的module就需要在interceptor中定义一些转发，同时要插桩，本身也不是不可接受，但是还有一个问题违背了我们拆分组件的初衷。组件之所以拆分就是因为需要划分职责，增加重用的概率，而且就算组建不重用，那么底层的很多公共的页面例如分享，选择照片，选择视频，之内的公共的一些页面可能由于没有上下级依赖需要arouter跳转的时候，都会遇到同一个问题： 作为转发的app层不在了，那么没有中间层进行转发，开始的分组件就变成了，离开中央集权之后就不可通讯的问题； 有没有改造之法？123456改造的方法分为基础上改动和彻底重建两种，各有利弊吧；A.一般成熟的大公司，或者说人力比较充沛的大公司，一般都选择了自己自建一个路由转发系统来绕开对于三方框架的依赖，后期的改动和定制都会成为瓶颈；那么市面上已经使用比较多的几个路由框架分别是，美团+饿了么+阿里都有自己的一套路由框架；B.改造arouter的aop和加载核心： arouter之所以有这个问题，根本原因在于，arouter通过aop生成类来做map映射的时候，是在同一个path中生成了诸多的以group为类名的类，那么肯定就有不同的module不能有相同的分组，问题的关键在于生成的逻辑是依赖group来进行的，同路径的自然不能同类名的； 针对这个限制，我们可以进行修改 改造之后的注意点？1改动比较大一些的框架，基础的框架，随之而来的肯定是要经过大量的验证和测试的，一个大意可能会影响面非常的大；验证自己的逻辑对于老逻辑有没有影响，开发之中一定要遵循开闭原则，对于修改关闭对于扩展开放； 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>arouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从碎片化的技能点到片的解决方案的认知改变]]></title>
    <url>%2F2018%2F09%2F13%2Flearn-structer%2F</url>
    <content type="text"><![CDATA[认知改变 如何进行改变 思考问题 认知改变初涉开发醉心于各种奇技淫巧，各种技能，喜欢堆砌很多技能数，当然这些年还是比较有意思的，毕竟想研究什么就研究什么。python脚本的简洁，h5的火热，java后台的了解，android的深度学习，各种语言方向的研究。 当然这些知识在构建一个行业的解决方案的时候，一样是会其效果的，像业务倒逼着技术的成长，对于知识点构建一个知识结构，可以从开始的知识构建得到经验，但是行业的解决方案，乃至于全行业的通用架构的提炼一直没有得到可以训练。当然在遇到比较体系的问题的时候，没有很优化的方案。 前贤有言：开发中的“坑”是对客观的不了解与不通达的主观妥协，确实忘了是谁说的，但是比较有道理。对一个使用中的三方库与文件的彻底了解再加上java的开源特性，使用三方开源的库与资料在调研充分的情况下，是不会有什么坑的。 如何进行改变上面说道了问题，那么就应该想想如何进行改变，成长总是伴随着不习惯不适应，所以这些改变可能让已经适应了舒适区的比较的不适，但是不适那种坐车晕车的强烈的不适，仅仅是一个像冬天吃一个冰激凌感官刺激体验新奇但是味觉比较的小煎熬的过程。 在接触到一个新的方向知识点的时候，希望能够想想这个点，能够加入到知识树中的哪个层级是解决哪个层级的问题，同时能够知道比之前的解决方案优化在哪，原理能不能探求清楚，能不能给别人讲述出来，在之后的一些场景能不能够适用上去；从来知识，路和书都没有白看的，都会在未来的某个时间，在某个转角探出头来，轻声跟你说你好，我过来看你了。无需多言，沉默，相视。 针对当前的方向如何进行成长当前主要的技能集中在安卓端，之后的方向，大变的可能小，但是按照现在软件市场的情况，不变是不可能的。之前的后端知识也需要在某个时间点直接引发出来。非常大的方向改动，需要非常多的业余时间来进行扩充知识面； 当前方向问题：1.后端，已经从事过，初级水平，还需要很多的项目与锻炼到高级； 2.机器学习与人工智能很想深入，但是可能入门基础准备比较多； 3.大数据处理，对于算法要求比较高，需要有技能储备； 当前已着手：后端有相关项目就投入一下；机器学习训练学习模型可以开始了； 当前方向成长路径技能图谱： https://blog.csdn.net/qq_39331713/article/details/82590218 外围与必须技能： https://mp.weixin.qq.com/s/XREOq821aaY0gwrlwrOQJA 思考问题 这个技术能解决什么问题（why） 比较适合在哪些场景应用（where + when) 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 &gt; 有什么优点和缺点（what） 了解前面的问题后，我才会开始去尝试写写Demo，或者更进一步去应用（How to use） 觉得有兴趣或者其实现很牛逼的情况下，我就去研究一下原理机制，看看源码等 （How it implements） 指导思想就是：从行业解决方案，进一步到技能技术的精深。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程定制输入框是否可输入保留光标定制]]></title>
    <url>%2F2017%2F12%2F10%2Finputbox-forbiddeninput%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 比较适合在哪些场景应用 源码研究过程 最后的方案 效果实现 资源链接 技术解决了什么问题这是一个典型的项目倒逼输入的例子。公司有蓝牙组件的需求，那么衍生出的定制需求也是很正常的。需求需要，输入框在保留光标的时候，同时有禁用键盘和启用键盘的操作。这个功能点的技术开始的诞生就是解决在edittext的控件使用时候，保留光标的时候还要禁用掉键盘的自动弹出(如果自定义键盘是同样这个套路的话，可能会有些问题，需要特殊处理)同时功能需求在有多个edittext时候依旧能够统一控制输入框的弹出软键盘功能。比较适合在哪些场景应用该技术适用于产品的具体场景，也可以稍微摘出来作为一个共用控件使用。 源码研究过程这个需求开始肯定要先看看edittext对于软件盘唤起的操作的源码。在edittext父类textview中找到了123456789/*** Sets whether the soft input method will be made visible when this * TextView gets focused. The default is true. */ @android.view.RemotableViewMethod public final void setShowSoftInputOnFocus(boolean show) &#123; createEditorIfNeeded(); mEditor.mShowSoftInputOnFocus = show; &#125; 方法代码段。但是直接使用调用方法来进行的时候会提示：Call requires API level 21 (current min is 18): android.widget.TextView#setShowSoftInputOnFocus less…android 18版本以上的才能够调用这个方法，为了兼容低版本，同时保证方法可用，想到了用反射来进行调用，处理掉反射的异常。 最后的方案如下：1234567891011121314151617181920212223242526272829303132333435/** * 禁止Edittext弹出软件盘，光标依然正常显示。 */ public void disableShowSoftInput() &#123; softinputSet(false); &#125; /** * 打开Edittext弹出软件盘，光标依然正常显示。 */ public void openShowSoftInput() &#123; softinputSet(true); &#125; public void softinputSet(boolean isShow)&#123; if (android.os.Build.VERSION.SDK_INT &lt;= 10) &#123; this.setInputType(InputType.TYPE_NULL); &#125; else &#123; Class&lt;EditText&gt; cls = EditText.class; Method method; try &#123; method = cls.getMethod(&quot;setShowSoftInputOnFocus&quot;, boolean.class); method.setAccessible(true); method.invoke(this, isShow); &#125; catch (Exception e) &#123; &#125; try &#123; method = cls.getMethod(&quot;setSoftInputShownOnFocus&quot;, boolean.class); method.setAccessible(true); method.invoke(this, isShow); &#125; catch (Exception e) &#123; &#125; &#125; &#125; 来控制整个的输入框的弹出与否 布局中的多个输入框的禁用效果实现实现了单个的效果，那么需要实现多个输入框的效果禁用时候，应该就可以大概看下layout对于这个的支持。因为edittext的软键盘弹出很多时候跟是否有焦点相关联。那么在layout中选取了一个布局进行支持的时候，可以看看这个布局viewgroup对于focus的实现方法和控制方法。直接选取了linearlayout的布局来进行研究。往父级进行浏览，最后跟到了view中去：12345678910111213141516171819202122232425262728293031/** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the previous selectable * item. */ public static final int FOCUS_BACKWARD = 0x00000001; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the next selectable * item. */ public static final int FOCUS_FORWARD = 0x00000002; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the left. */ public static final int FOCUS_LEFT = 0x00000011; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus up. */ public static final int FOCUS_UP = 0x00000021; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the right. */ public static final int FOCUS_RIGHT = 0x00000042; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus down. */ public static final int FOCUS_DOWN = 0x00000082; view 对于子view的focus的标志有以上几种，标志着在子view的焦点的变化。这时候大概可以关注一下focus_down了，见名知意。查阅了官方文档，描述也是如此，是在子view中找到下一个可以获取焦点的位置。那么方案就可以定下来了。 布局中多输入框禁用效果方案在布局中找到当前的获取到焦点的view，同时往上找一个子view或者是往下找一个子viwe即可。实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 光标往下去一个输入组件 */ public void next()&#123; boolean isThis = false; View current = this.findFocus(); ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views )&#123; if(isThis)&#123; isThis = false; view.requestFocus(); return ; &#125; if(current == view)&#123; isThis = true; &#125; &#125; &#125; /** * 光标往上去一个输入组件 */ public void previous()&#123; View current = this.findFocus(); ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(int i = 0 ; i &lt; views.size(); i++)&#123; if(current == views.get(i))&#123; if(i &gt;= 1)&#123; views.get(i-1).requestFocus(); &#125; &#125; &#125; &#125; /** * 禁用子view的软键盘自动弹出 */ public void forbidenAllChildSoftinput()&#123; KeyBoardDisableEditText editText; ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views)&#123; if(view instanceof KeyBoardDisableEditText)&#123; editText = (KeyBoardDisableEditText) view; editText.disableShowSoftInput(); &#125; &#125; &#125; /** * 启用子view的软键盘自动弹出 */ public void startAllChildSoftinput()&#123; KeyBoardDisableEditText editText; ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views)&#123; if(view instanceof KeyBoardDisableEditText)&#123; editText = (KeyBoardDisableEditText) view; editText.openShowSoftInput(); &#125; &#125; &#125; 同时在layout中还开放了一个可以控制布局中所有sorftinput弹出事件的方法。那么定制到这里是可以完全解决问题了的。原理就是通过源码来进行一个hack操作而已。demo可能有用先挂出来： 传送门之大传送之术 传送门之布局控制传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>定制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程通用能力-变体包衍生多个定制工程解决方案(java,res,lib全方位定制问题)]]></title>
    <url>%2F2017%2F11%2F18%2Fproject-productflavor-newproject%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题 适合在哪种场景使用 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点 上酸菜，咳咳，上代码例子 这个技术解决了什么问题业务中遇到了一个问题需要定制一个版本给到另外的需求，但是主体的业务逻辑功能不用大动，需要定制的页面就是登录页面与所有的跟本软件相关的主体名称需要全部替换掉，颜色字体，启动页，升级包。本身想要的数据隔离，在后端的评估之后，被舍弃掉了，那么定制的工作都落到了客户端的头上。也算是一个比较好的成长时间，所以欣然接受吧。业务来倒逼输出也是不错的。如果业务需要客户端承担更大的优化与定制，对于个人的成长也是很不错的。哦，有点说教了，还是进入主题吧。从安卓的官方文档中也可以查阅到一些关于变体包的资料，传送门之官方文档中国站传送门当然如果只是官方文档的搬运，是不会有这篇文章的。 适合在哪种场景使用当有需要定制不同的字体(当然现在google可以通过下载字体进行替换),颜色值(也可以通过后台动态的进行切换)，各种启动页，各种登录页，各种主体提示与标志的定制。那么这些改动可能涉及到java源代码的定制，res中string，values，colors的定制，甚至是lib,so库的定制。那么被分支切换与升级合并冲突，每次的不同版本升级折腾的要死要死的你，可以考虑使用一下google的这套东西。 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点关于解决场景中的方法确实不少，条条大路通罗马，上面讲场景的时候，顺带就已经说过了。那么现在可以来说说优缺点吧优点:1.主体的逻辑可以通用2.改动与共通的部分清晰好维护缺点：1.同样要承受一部分的定制之苦 上酸菜，咳咳，上代码例子假设变体工程只有一个，但是相信我，开了这个定制的口子那么后面的事情就不止一个变体能解决的了，两个也不行。我们先讨论只有一个变体的情况：这个配置里，不止有例子该有的配置，还为你们打开了另一个大门，一个完整的公司级项目里面会涉及到的定制也包含在里面了。前面是签名的配置，这个不必多说，是为了下面的变体包不同的签名而存在的，包区分是不是同一个包，能不能被装在同一个手机上，就是通过报名和签名的不同来的，所以这两方面的定制必不可少。往下到productflavor的配置，产生的两个分支，这个名字可以任意复合groovy语言规则的名字都可以，新建之后需要在项目新建一个跟main同级的命名跟分支名相同的文件夹文件夹下面新建需要的定制文件夹main文件夹下有的文件夹都可以新建也都可以定制。那么我们先建这两个文件夹，新建的变体分支在buildvariants中可以进行动态的切换，我们现在在custom的分支下，所以custom的java是加载到编译器的，res是加载过的。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android event 事件分发的一些实用解析与源码分析汇总]]></title>
    <url>%2F2017%2F10%2F09%2Ftouchevent-all%2F</url>
    <content type="text"><![CDATA[前言 事件分发的一些概念 QA 源码链接 前言工程中的一些需求需要定制很多的view，而定制的view如何进行这里不进行展开，但是其中遇到的一个问题足以引起重视，那就是view需要处理action事件(如 down , up , move ,cancle )，而总是出现处理了view的touch事件之后，在对view的onclicklistener监听的时候，监听不到点击事件，开始的处理是在网上查(zhan)找(tie)了下。现在好整以暇，可以看看究竟是什么样的机制让ontouch的事件监听了之后，没有onclicklistener的。或者是自己的使用姿势不对。事件分发的一些概念 事件：用户触摸屏幕产生的点击事件 系统将用户的操作事件包装成了一个motionevent的对象。(包含发生触摸的位置，时间，历史记录，手势动作等) 从源码的区分上来说： MOtionEvent.ACTION_DOWN: 用户按下事件 MotionEvent.ACTION_MOVE: 用户移动手指事件 MotionEvent.ACTION_CANCLE: 非用户操作取消事件 MotionEvent.ACTION_UP: 用户手指抬起事件用户的一次操作的事件列 用户的一次手指从按下到抬起的产生的一系列事件。 事件分发的几个分类window/activity , viewgroup 与 view讨论的事件分发除了是由docview分发的onclicklistener之外的诸如：dispatchevent,onintercepttouchevent,ontouchevent的一些事件，其中： widow/activity:dispatchevent,ontouchevent(没有onintercepttouchevent) viewgroup : dispatchevent,ontouchevent(没有onintercepttouchevent) view : dispatchevent,ontouchevent,onintercepttouchevent 基本的传递顺序是： activity—-&gt; viewgroup —-&gt; view e.g 在有多个viewgroup嵌套的时候，遵循一层一层往下传递的规律。 事件分发相关的方法事件分发在activity,viewgroup,view中传递的基本原则 事件分发QA1.view的事件分发的时候，ontouch拦截返回true/false时候，view的onclicklistener都不响应的问题。首先明白view的onclicklistener事件是docview或者说是acitivity的rootview分发给每个view的，那么首先我们要保证在顶层的activity要能获得事件。上图的分类是有问题的，当我们在view中拦截了ontouchevent的时候，传递的是false的时候，表示我们不处理给到父级来处理，但是在activity中没有接到相应的事件，没有给到onclicklistener点击事件。现象如下： 而当我们放开view的ontouchevent让而调用super的事件，那么会得到相应的结果。会响应view的onclick事件，所以，返回false和返回super是不一样的，对于onclick事件绑定来说，必须要把view的ontouchevent给到super，才能够让docview把事件给到view。 2.在上个实验中我们看到了acitivty中调用了两次的ontouchevent。用户的一次点击实际上是一个action_down和一次action_up组成的，所以，是传递了两个motionevent出来，那么activity–&gt;viewgroup—&gt;view是需要走两次的。 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>event事件解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[so库全解析]]></title>
    <url>%2F2017%2F09%2F18%2Fso-source-design%2F</url>
    <content type="text"><![CDATA[google android系统so库比较多的原因 android cpu架构分类 android如何去寻找so库原理 几个需要明白的概念 大厂对于so架构的一些取舍 总结 google android系统so库比较多的原因 为适配众多的cpu架构，实际就是指令集的区别，在开始从复杂指令集改动到简易指令集的微软架构之后，又分出若干阵营，那么这个地方就不展开了，展开我怕篇幅不太够啊，少年。 android cpu架构分类android 当前支持的七种cpu架构Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI~ABI 应用程序二进制接口(Application binary interface)定义了二进制文件(so库)如何运行在相应的系统上。 每种cpu架构对应着一个ABIarmeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64 android如何去寻找so库原理android如何去寻找so库原理图解 android系统寻找so库的顺序，先区分架构，再去寻找完美适配的架构文件夹，若果找不到继续向兼容的架构寻找，匹配架构成功后，加载这个架构下所有的so到data文件夹中，如果在data中找不到应用中使用到的so库，那么会报异常，so link错误等等，不会再到其他架构中去扫描。 几个需要明白的概念主ABI库主ABI库： 与系统影响本身机器对应的ABI库辅助ABI库： 与系统也支持的ABI对应而，为实现最佳性能，应该提供主abi库 各个架构库支持的ABIX86 ： 可以运行在armeabi/armeabi-v7a 主要的ABI是X86,辅助ABI是armeabi-v7amips: 只定义了主ABI是mips(但是极少用于手机，可以忽略)armeabi-v7a ： 主 armeabi-v7a ， 辅助armeabi 只提供一种架构优缺点只提供一种架构优点：可以减小包的体积缺点： 只提供一种架构，而忽视其他架构，那么会影响到性能和兼容，同时也将丢失掉专门为64位优化的性能。 android找so库对于软件开发影响从根本上来说，系统只会把他区分架构的文件夹整个复制到data目录，那么造成一个问题就是，每个架构的文件夹下都应该是so库的全量，如果三方服务供应商，只给了一个armeabi-v7a 的架构，而工程中准备只放一个armeabi的文件夹来减小包大小，那么应该将v7a中的so库拷贝到armeabi中。 同时在运行在androidstudio工程中的build.gradle defaultConfig 中添加： ndk { abiFilters “armeabi” }在打包中，只包含armeabi的架构。 大厂对于so架构的一些取舍armeabi-v7a : facebook , twitterarmeabi: 淘宝 微信armeabi : 淘票票 还是来一个图来说明这个东西吧，毕竟没图你说个啥啊： 我可以大概算一个总结那么实际中我们的取舍遵从的原则：1.为减小体积，只保留armeabi与armeabi-v7a，一般只保留一个2.若只有一个架构，那么其他架构中的so，保留的文件夹下有有全量。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>so库实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[values在碎片化各种屏幕中的系统加载策略问题探讨及ui适配的选择]]></title>
    <url>%2F2017%2F09%2F15%2F2017-09-15-md%2F</url>
    <content type="text"><![CDATA[android寻找资源策略 values 两种系统识别文件夹，细分三种 几种方式系统加 android寻找资源策略 values 两种系统识别文件夹，细分三种values-XXXXxXXXX values-swXXXdp (values-hXXXdp values-wXXXdp)三种系统识别的文件夹命令分别是指定分辨率，适配优先宽度，宽高适配 几种方式系统加载策略的探索项目中使用到了多个values来进行适配的问题，想从根本上弄清楚系统在加载的时候，对文件夹取用策略的判断问题，用实际例子对比了一下swXXXdp与values-1920X1080和默认的values的加载其中的策略指定问题，混合模式下，系统对values的取用问题。ok，开始吧。 添加values-1790X1080,values-1794X1076,values-1794X1080与values-sw361dp前三个文件夹用来对比在跟屏幕真实分辨率相差一些数值的时候，系统会加载那个文件夹下的配置。先用三个文件夹运行，观察结果： 加载了，values-sw361dp 当然是运行的完美契合的那个分辨率了，那么当我们在实际开发的时候，屏幕碎片化太大的时候，这种情况是可遇不可求的，故而需要去测试系统对与不完美契合的情况的处理，删除掉完美契合文件夹： 删除掉之后 运行结果是： 1920X1148 加载到了1920X1148的values，那么说明在 1916X1152 与 1920X1148两个相近的宽高差值相同的文件夹中选择了高来进行优先选择，但是不能排除系统是把第一参数进行对比，而不是将values的匹配高进行优先匹配的，好吧，下面验证一下：改名为： 删除资源 运行结果： 加载的还是高匹配高的那个文件夹，那么结论：系统对不能完美匹配的values文件，遵循的是，宽高差值绝对值进行对比，如果宽高对于当前屏幕分辨率差值小的进行加载，如果当宽高绝对值差值相同的时候，以高匹配度高的values进行加载。上面对比了在使用px来区分values的一些加载规则，那么当swXXXdp出现的时候，(sw—-small width)小宽度概念，当系统的宽度dp值大于该值的时候，加载这套设置。问题在于dp与px方式同时出现的时候，系统对于优先级的判定问题。下面进行判定：加入混合的值文件夹： 运行结果： 算是一个小总结google还是对dp情有独钟啊，1152/3= 384dp跟360还差那么多，要是在一个水平线上来进行对比的话，真真的应该加载1920X1152啊，完美适配的呢，说好的做彼此的天屎的，呸，天屎，算了。但是不管google怎么优先级，从细分上来说，如果是为了适配smartbar这个坑的话，一般来说，用px的values-1920X1152方式来进行细分适配要更加的精确，更能完美处理掉这个问题，毕竟还是在同一个水平上来处理的。但是官方是推sw-XXXdp的。综上所述：values-swXXXdp &gt; values-XXXXxXXXX &gt; values ;注： values-XXXXXxXXXXX 方式的时候，通过宽高跟屏幕分辨率的差值绝对值来进行对比，优先高。好吧，可能有人在等源码，我一起放上来吧 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>values实战</tag>
      </tags>
  </entry>
</search>
