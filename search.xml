<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[arouter使用阶段性认知]]></title>
    <url>%2F2018%2F09%2F13%2Farouter-thinking%2F</url>
    <content type="text"><![CDATA[android寻找资源策略&lt;!– values 两种系统识别文件夹，细分三种values-XXXXxXXXX values-swXXXdp (values-hXXXdp values-wXXXdp)三种系统识别的文件夹命令分别是指定分辨率，适配优先宽度，宽高适配 几种方式系统加载策略的探索项目中使用到了多个values来进行适配的问题，想从根本上弄清楚系统在加载的时候，对文件夹取用策略的判断问题，用实际例子对比了一下swXXXdp与values-1920X1080和默认的values的加载其中的策略指定问题，混合模式下，系统对values的取用问题。ok，开始吧。 添加values-1790X1080,values-1794X1076,values-1794X1080与values-sw361dp前三个文件夹用来对比在跟屏幕真实分辨率相差一些数值的时候，系统会加载那个文件夹下的配置。先用三个文件夹运行，观察结果： 当然是运行的完美契合的那个分辨率了，那么当我们在实际开发的时候，屏幕碎片化太大的时候，这种情况是可遇不可求的，故而需要去测试系统对与不完美契合的情况的处理，删除掉完美契合文件夹： 运行结果是： 加载到了1920X1148的values，那么说明在 1916X1152 与 1920X1148两个相近的宽高差值相同的文件夹中选择了高来进行优先选择，但是不能排除系统是把第一参数进行对比，而不是将values的匹配高进行优先匹配的，好吧，下面验证一下：改名为： 运行结果： 加载的还是高匹配高的那个文件夹，那么结论：系统对不能完美匹配的values文件，遵循的是，宽高差值绝对值进行对比，如果宽高对于当前屏幕分辨率差值小的进行加载，如果当宽高绝对值差值相同的时候，以高匹配度高的values进行加载。上面对比了在使用px来区分values的一些加载规则，那么当swXXXdp出现的时候，(sw—-small width)小宽度概念，当系统的宽度dp值大于该值的时候，加载这套设置。问题在于dp与px方式同时出现的时候，系统对于优先级的判定问题。下面进行判定：加入混合的值文件夹： 运行结果： 算是一个小总结google还是对dp情有独钟啊，1152/3= 384dp跟360还差那么多，要是在一个水平线上来进行对比的话，真真的应该加载1920X1152啊，完美适配的呢，说好的做彼此的天屎的，呸，天屎，算了。但是不管google怎么优先级，从细分上来说，如果是为了适配smartbar这个坑的话，一般来说，用px的values-1920X1152方式来进行细分适配要更加的精确，更能完美处理掉这个问题，毕竟还是在同一个水平上来处理的。但是官方是推sw-XXXdp的。综上所述：values-swXXXdp &gt; values-XXXXxXXXX &gt; values ;注： values-XXXXXxXXXXX 方式的时候，通过宽高跟屏幕分辨率的差值绝对值来进行对比，优先高。好吧，可能有人在等源码，我一起放上来吧 –&gt; 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>arouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从碎片化的技能点到片的解决方案的认知改变]]></title>
    <url>%2F2018%2F09%2F13%2Flearn-structer%2F</url>
    <content type="text"><![CDATA[认知改变初涉开发醉心于各种奇技淫巧，各种技能，喜欢堆砌很多技能数，当然这些年还是比较有意思的，毕竟想研究什么就研究什么。python脚本的简洁，h5的火热，java后台的了解，android的深度学习，各种语言方向的研究。当然这些知识在构建一个行业的解决方案的时候，一样是会其效果的，像业务倒逼着技术的成长，对于知识点构建一个知识结构，可以从开始的知识构建得到经验，但是行业的解决方案，乃至于全行业的通用架构的提炼一直没有得到可以训练。当然在遇到比较体系的问题的时候，没有很优化的方案。前贤有言：开发中的“坑”是对客观的不了解与不通达的主观妥协，确实忘了是谁说的，但是比较有道理。对一个使用中的三方库与文件的彻底了解再加上java的开源特性，使用三方开源的库与资料在调研充分的情况下，是不会有什么坑的。 如何进行改变上面说道了问题，那么就应该想想如何进行改变，成长总是伴随着不习惯不适应，所以这些改变可能让已经适应了舒适区的比较的不适，但是不适那种坐车晕车的强烈的不适，仅仅是一个像冬天吃一个冰激凌感官刺激体验新奇但是味觉比较的小煎熬的过程。 思考问题 这个技术能解决什么问题（why） 比较适合在哪些场景应用（where + when) 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 &gt; 有什么优点和缺点（what） 了解前面的问题后，我才会开始去尝试写写Demo，或者更进一步去应用（How to use） 觉得有兴趣或者其实现很牛逼的情况下，我就去研究一下原理机制，看看源码等 （How it implements） 指导思想就是：从行业解决方案，进一步到技能技术的精深。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程定制输入框是否可输入保留光标定制]]></title>
    <url>%2F2017%2F12%2F10%2Finputbox-forbiddeninput%2F</url>
    <content type="text"><![CDATA[技术解决了什么问题这是一个典型的项目倒逼输入的例子。公司有蓝牙组件的需求，那么衍生出的定制需求也是很正常的。需求需要，输入框在保留光标的时候，同时有禁用键盘和启用键盘的操作。这个功能点的技术开始的诞生就是解决在edittext的控件使用时候，保留光标的时候还要禁用掉键盘的自动弹出(如果自定义键盘是同样这个套路的话，可能会有些问题，需要特殊处理)同时功能需求在有多个edittext时候依旧能够统一控制输入框的弹出软键盘功能。 比较适合在哪些场景应用该技术适用于产品的具体场景，也可以稍微摘出来作为一个共用控件使用。 源码研究过程这个需求开始肯定要先看看edittext对于软件盘唤起的操作的源码。在edittext父类textview中找到了123456789/*** Sets whether the soft input method will be made visible when this * TextView gets focused. The default is true. */ @android.view.RemotableViewMethod public final void setShowSoftInputOnFocus(boolean show) &#123; createEditorIfNeeded(); mEditor.mShowSoftInputOnFocus = show; &#125; 方法代码段。但是直接使用调用方法来进行的时候会提示：Call requires API level 21 (current min is 18): android.widget.TextView#setShowSoftInputOnFocus less…android 18版本以上的才能够调用这个方法，为了兼容低版本，同时保证方法可用，想到了用反射来进行调用，处理掉反射的异常。 最后的方案如下：1234567891011121314151617181920212223242526272829303132333435/** * 禁止Edittext弹出软件盘，光标依然正常显示。 */ public void disableShowSoftInput() &#123; softinputSet(false); &#125; /** * 打开Edittext弹出软件盘，光标依然正常显示。 */ public void openShowSoftInput() &#123; softinputSet(true); &#125; public void softinputSet(boolean isShow)&#123; if (android.os.Build.VERSION.SDK_INT &lt;= 10) &#123; this.setInputType(InputType.TYPE_NULL); &#125; else &#123; Class&lt;EditText&gt; cls = EditText.class; Method method; try &#123; method = cls.getMethod(&quot;setShowSoftInputOnFocus&quot;, boolean.class); method.setAccessible(true); method.invoke(this, isShow); &#125; catch (Exception e) &#123; &#125; try &#123; method = cls.getMethod(&quot;setSoftInputShownOnFocus&quot;, boolean.class); method.setAccessible(true); method.invoke(this, isShow); &#125; catch (Exception e) &#123; &#125; &#125; &#125; 来控制整个的输入框的弹出与否 布局中的多个输入框的禁用效果实现实现了单个的效果，那么需要实现多个输入框的效果禁用时候，应该就可以大概看下layout对于这个的支持。因为edittext的软键盘弹出很多时候跟是否有焦点相关联。那么在layout中选取了一个布局进行支持的时候，可以看看这个布局viewgroup对于focus的实现方法和控制方法。直接选取了linearlayout的布局来进行研究。往父级进行浏览，最后跟到了view中去：12345678910111213141516171819202122232425262728293031/** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the previous selectable * item. */ public static final int FOCUS_BACKWARD = 0x00000001; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the next selectable * item. */ public static final int FOCUS_FORWARD = 0x00000002; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the left. */ public static final int FOCUS_LEFT = 0x00000011; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus up. */ public static final int FOCUS_UP = 0x00000021; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus to the right. */ public static final int FOCUS_RIGHT = 0x00000042; /** * Use with &#123;@link #focusSearch(int)&#125;. Move focus down. */ public static final int FOCUS_DOWN = 0x00000082; view 对于子view的focus的标志有以上几种，标志着在子view的焦点的变化。这时候大概可以关注一下focus_down了，见名知意。查阅了官方文档，描述也是如此，是在子view中找到下一个可以获取焦点的位置。那么方案就可以定下来了。 布局中多输入框禁用效果方案在布局中找到当前的获取到焦点的view，同时往上找一个子view或者是往下找一个子viwe即可。实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 光标往下去一个输入组件 */ public void next()&#123; boolean isThis = false; View current = this.findFocus(); ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views )&#123; if(isThis)&#123; isThis = false; view.requestFocus(); return ; &#125; if(current == view)&#123; isThis = true; &#125; &#125; &#125; /** * 光标往上去一个输入组件 */ public void previous()&#123; View current = this.findFocus(); ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(int i = 0 ; i &lt; views.size(); i++)&#123; if(current == views.get(i))&#123; if(i &gt;= 1)&#123; views.get(i-1).requestFocus(); &#125; &#125; &#125; &#125; /** * 禁用子view的软键盘自动弹出 */ public void forbidenAllChildSoftinput()&#123; KeyBoardDisableEditText editText; ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views)&#123; if(view instanceof KeyBoardDisableEditText)&#123; editText = (KeyBoardDisableEditText) view; editText.disableShowSoftInput(); &#125; &#125; &#125; /** * 启用子view的软键盘自动弹出 */ public void startAllChildSoftinput()&#123; KeyBoardDisableEditText editText; ArrayList&lt;View&gt; views = this.getFocusables(View.FOCUS_DOWN); for(View view : views)&#123; if(view instanceof KeyBoardDisableEditText)&#123; editText = (KeyBoardDisableEditText) view; editText.openShowSoftInput(); &#125; &#125; &#125; 同时在layout中还开放了一个可以控制布局中所有sorftinput弹出事件的方法。那么定制到这里是可以完全解决问题了的。原理就是通过源码来进行一个hack操作而已。demo可能有用先挂出来： 传送门之大传送之术 传送门之布局控制传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>定制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程通用能力-变体包衍生多个定制工程解决方案(java,res,lib全方位定制问题)]]></title>
    <url>%2F2017%2F11%2F18%2Fproject-productflavor-newproject%2F</url>
    <content type="text"><![CDATA[这个技术解决了什么问题业务中遇到了一个问题需要定制一个版本给到另外的需求，但是主体的业务逻辑功能不用大动，需要定制的页面就是登录页面与所有的跟本软件相关的主体名称需要全部替换掉，颜色字体，启动页，升级包。本身想要的数据隔离，在后端的评估之后，被舍弃掉了，那么定制的工作都落到了客户端的头上。也算是一个比较好的成长时间，所以欣然接受吧。业务来倒逼输出也是不错的。如果业务需要客户端承担更大的优化与定制，对于个人的成长也是很不错的。哦，有点说教了，还是进入主题吧。从安卓的官方文档中也可以查阅到一些关于变体包的资料，传送门之官方文档中国站传送门当然如果只是官方文档的搬运，是不会有这篇文章的。 适合在哪种场景使用当有需要定制不同的字体(当然现在google可以通过下载字体进行替换),颜色值(也可以通过后台动态的进行切换)，各种启动页，各种登录页，各种主体提示与标志的定制。那么这些改动可能涉及到java源代码的定制，res中string，values，colors的定制，甚至是lib,so库的定制。那么被分支切换与升级合并冲突，每次的不同版本升级折腾的要死要死的你，可以考虑使用一下google的这套东西。 这个技术跟我已经掌握的哪个知识或技能类似，有什么差别、有什么特点、 有什么优点和缺点关于解决场景中的方法确实不少，条条大路通罗马，上面讲场景的时候，顺带就已经说过了。那么现在可以来说说优缺点吧优点:1.主体的逻辑可以通用2.改动与共通的部分清晰好维护缺点：1.同样要承受一部分的定制之苦 上酸菜，咳咳，上代码例子假设变体工程只有一个，但是相信我，开了这个定制的口子那么后面的事情就不止一个变体能解决的了，两个也不行。我们先讨论只有一个变体的情况：这个配置里，不止有例子该有的配置，还为你们打开了另一个大门，一个完整的公司级项目里面会涉及到的定制也包含在里面了。前面是签名的配置，这个不必多说，是为了下面的变体包不同的签名而存在的，包区分是不是同一个包，能不能被装在同一个手机上，就是通过报名和签名的不同来的，所以这两方面的定制必不可少。往下到productflavor的配置，产生的两个分支，这个名字可以任意复合groovy语言规则的名字都可以，新建之后需要在项目新建一个跟main同级的命名跟分支名相同的文件夹文件夹下面新建需要的定制文件夹main文件夹下有的文件夹都可以新建也都可以定制。那么我们先建这两个文件夹，新建的变体分支在buildvariants中可以进行动态的切换，我们现在在custom的分支下，所以custom的java是加载到编译器的，res是加载过的。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android event 事件分发的一些实用解析与源码分析汇总]]></title>
    <url>%2F2017%2F10%2F09%2Ftouchevent-all%2F</url>
    <content type="text"><![CDATA[前言工程中的一些需求需要定制很多的view，而定制的view如何进行这里不进行展开，但是其中遇到的一个问题足以引起重视，那就是view需要处理action事件(如 down , up , move ,cancle )，而总是出现处理了view的touch事件之后，在对view的onclicklistener监听的时候，监听不到点击事件，开始的处理是在网上查(zhan)找(tie)了下。现在好整以暇，可以看看究竟是什么样的机制让ontouch的事件监听了之后，没有onclicklistener的。或者是自己的使用姿势不对。 事件分发的一些概念事件：用户触摸屏幕产生的点击事件 系统将用户的操作事件包装成了一个motionevent的对象。(包含发生触摸的位置，时间，历史记录，手势动作等) 从源码的区分上来说： MOtionEvent.ACTION_DOWN: 用户按下事件 MotionEvent.ACTION_MOVE: 用户移动手指事件 MotionEvent.ACTION_CANCLE: 非用户操作取消事件 MotionEvent.ACTION_UP: 用户手指抬起事件 用户的一次操作的事件列用户的一次手指从按下到抬起的产生的一系列事件。 事件分发的几个分类window/activity , viewgroup 与 view讨论的事件分发除了是由docview分发的onclicklistener之外的诸如：dispatchevent,onintercepttouchevent,ontouchevent的一些事件，其中： widow/activity:dispatchevent,ontouchevent(没有onintercepttouchevent) viewgroup : dispatchevent,ontouchevent(没有onintercepttouchevent) view : dispatchevent,ontouchevent,onintercepttouchevent 基本的传递顺序是： activity—-&gt; viewgroup —-&gt; view e.g 在有多个viewgroup嵌套的时候，遵循一层一层往下传递的规律。 事件分发相关的方法事件分发在activity,viewgroup,view中传递的基本原则 事件分发QA1.view的事件分发的时候，ontouch拦截返回true/false时候，view的onclicklistener都不响应的问题。首先明白view的onclicklistener事件是docview或者说是acitivity的rootview分发给每个view的，那么首先我们要保证在顶层的activity要能获得事件。上图的分类是有问题的，当我们在view中拦截了ontouchevent的时候，传递的是false的时候，表示我们不处理给到父级来处理，但是在activity中没有接到相应的事件，没有给到onclicklistener点击事件。现象如下： 而当我们放开view的ontouchevent让而调用super的事件，那么会得到相应的结果。会响应view的onclick事件，所以，返回false和返回super是不一样的，对于onclick事件绑定来说，必须要把view的ontouchevent给到super，才能够让docview把事件给到view。 2.在上个实验中我们看到了acitivty中调用了两次的ontouchevent。用户的一次点击实际上是一个action_down和一次action_up组成的，所以，是传递了两个motionevent出来，那么activity–&gt;viewgroup—&gt;view是需要走两次的。 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>event事件解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[so库全解析]]></title>
    <url>%2F2017%2F09%2F18%2Fso-source-design%2F</url>
    <content type="text"><![CDATA[google android系统so库比较多的原因为适配众多的cpu架构，实际就是指令集的区别，在开始从复杂指令集改动到简易指令集的微软架构之后，又分出若干阵营，那么这个地方就不展开了，展开我怕篇幅不太够啊，少年。 android cpu架构分类android 当前支持的七种cpu架构Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。~ABI 应用程序二进制接口(Application binary interface)定义了二进制文件(so库)如何运行在相应的系统上。 每种cpu架构对应着一个ABIarmeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64 android如何去寻找so库原理android如何去寻找so库原理图解 android系统寻找so库的顺序，先区分架构，再去寻找完美适配的架构文件夹，若果找不到继续向兼容的架构寻找，匹配架构成功后，加载这个架构下所有的so到data文件夹中，如果在data中找不到应用中使用到的so库，那么会报异常，so link错误等等，不会再到其他架构中去扫描。 几个需要明白的概念主ABI库主ABI库： 与系统影响本身机器对应的ABI库辅助ABI库： 与系统也支持的ABI对应而，为实现最佳性能，应该提供主abi库 各个架构库支持的ABIX86 ： 可以运行在armeabi/armeabi-v7a 主要的ABI是X86,辅助ABI是armeabi-v7amips: 只定义了主ABI是mips(但是极少用于手机，可以忽略)armeabi-v7a ： 主 armeabi-v7a ， 辅助armeabi 只提供一种架构优缺点只提供一种架构优点：可以减小包的体积缺点： 只提供一种架构，而忽视其他架构，那么会影响到性能和兼容，同时也将丢失掉专门为64位优化的性能。 android找so库对于软件开发影响从根本上来说，系统只会把他区分架构的文件夹整个复制到data目录，那么造成一个问题就是，每个架构的文件夹下都应该是so库的全量，如果三方服务供应商，只给了一个armeabi-v7a 的架构，而工程中准备只放一个armeabi的文件夹来减小包大小，那么应该将v7a中的so库拷贝到armeabi中。 同时在运行在androidstudio工程中的build.gradle defaultConfig 中添加： ndk { abiFilters “armeabi” }在打包中，只包含armeabi的架构。 大厂对于so架构的一些取舍armeabi-v7a : facebook , twitterarmeabi: 淘宝 微信armeabi : 淘票票 还是来一个图来说明这个东西吧，毕竟没图你说个啥啊： 我可以大概算一个总结那么实际中我们的取舍遵从的原则：1.为减小体积，只保留armeabi与armeabi-v7a，一般只保留一个2.若只有一个架构，那么其他架构中的so，保留的文件夹下有有全量。]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>so库实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[values在碎片化各种屏幕中的系统加载策略问题探讨及ui适配的选择]]></title>
    <url>%2F2017%2F09%2F15%2F2017-09-15-md%2F</url>
    <content type="text"><![CDATA[android寻找资源策略 values 两种系统识别文件夹，细分三种values-XXXXxXXXX values-swXXXdp (values-hXXXdp values-wXXXdp)三种系统识别的文件夹命令分别是指定分辨率，适配优先宽度，宽高适配 几种方式系统加载策略的探索项目中使用到了多个values来进行适配的问题，想从根本上弄清楚系统在加载的时候，对文件夹取用策略的判断问题，用实际例子对比了一下swXXXdp与values-1920X1080和默认的values的加载其中的策略指定问题，混合模式下，系统对values的取用问题。ok，开始吧。 添加values-1790X1080,values-1794X1076,values-1794X1080与values-sw361dp前三个文件夹用来对比在跟屏幕真实分辨率相差一些数值的时候，系统会加载那个文件夹下的配置。先用三个文件夹运行，观察结果： 当然是运行的完美契合的那个分辨率了，那么当我们在实际开发的时候，屏幕碎片化太大的时候，这种情况是可遇不可求的，故而需要去测试系统对与不完美契合的情况的处理，删除掉完美契合文件夹： 运行结果是： 加载到了1920X1148的values，那么说明在 1916X1152 与 1920X1148两个相近的宽高差值相同的文件夹中选择了高来进行优先选择，但是不能排除系统是把第一参数进行对比，而不是将values的匹配高进行优先匹配的，好吧，下面验证一下：改名为： 运行结果： 加载的还是高匹配高的那个文件夹，那么结论：系统对不能完美匹配的values文件，遵循的是，宽高差值绝对值进行对比，如果宽高对于当前屏幕分辨率差值小的进行加载，如果当宽高绝对值差值相同的时候，以高匹配度高的values进行加载。上面对比了在使用px来区分values的一些加载规则，那么当swXXXdp出现的时候，(sw—-small width)小宽度概念，当系统的宽度dp值大于该值的时候，加载这套设置。问题在于dp与px方式同时出现的时候，系统对于优先级的判定问题。下面进行判定：加入混合的值文件夹： 运行结果： 算是一个小总结google还是对dp情有独钟啊，1152/3= 384dp跟360还差那么多，要是在一个水平线上来进行对比的话，真真的应该加载1920X1152啊，完美适配的呢，说好的做彼此的天屎的，呸，天屎，算了。但是不管google怎么优先级，从细分上来说，如果是为了适配smartbar这个坑的话，一般来说，用px的values-1920X1152方式来进行细分适配要更加的精确，更能完美处理掉这个问题，毕竟还是在同一个水平上来处理的。但是官方是推sw-XXXdp的。综上所述：values-swXXXdp &gt; values-XXXXxXXXX &gt; values ;注： values-XXXXXxXXXXX 方式的时候，通过宽高跟屏幕分辨率的差值绝对值来进行对比，优先高。好吧，可能有人在等源码，我一起放上来吧 传送门之大传送之术]]></content>
      <categories>
        <category>android技能</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>values实战</tag>
      </tags>
  </entry>
</search>
